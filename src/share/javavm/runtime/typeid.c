/*
 * @(#)typeid.c	1.114 06/10/10
 *
 * Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.  
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER  
 *   
 * This program is free software; you can redistribute it and/or  
 * modify it under the terms of the GNU General Public License version  
 * 2 only, as published by the Free Software Foundation.   
 *   
 * This program is distributed in the hope that it will be useful, but  
 * WITHOUT ANY WARRANTY; without even the implied warranty of  
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  
 * General Public License version 2 for more details (a copy is  
 * included at /legal/license.txt).   
 *   
 * You should have received a copy of the GNU General Public License  
 * version 2 along with this work; if not, write to the Free Software  
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
 * 02110-1301 USA   
 *   
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa  
 * Clara, CA 95054 or visit www.sun.com if you need additional  
 * information or have any questions. 
 *
 */

#include "javavm/include/defs.h"
#include "javavm/include/objects.h"
#include "javavm/include/classes.h"
#include "javavm/include/typeid.h"
#include "javavm/include/typeid_impl.h"
#include "javavm/include/globals.h"
#include "javavm/include/signature.h"
#include "javavm/include/utils.h"
#include "javavm/include/common_exceptions.h"
#include "javavm/include/preloader.h"
#include "javavm/include/packages.h"
#include "javavm/include/clib.h"
#include "javavm/include/porting/system.h"

/* TypeIDs: Internal Mechanics / What's under the covers?
   =====================================================
   Before reading this, please read the comment lock at the top of typeid.h
   to understand some of the abstract concepts that will be referred to
   below.

   NOTE: Most of the data structures discussed here are defined in
   typeid_impl.h.

   TypeID Databases / Storage
   ==========================
   Inside the typeID system, there are 4 databases:

   1. CVMtypeidClassEntries       - tracks class names
   2. CVMtypeidNameEntries        - tracks field and method names
   3. CVMtypeidMethodSigEntries   - tracks method signatures
   4. CVMtypeidNameAndTypeEntries - track name and type pairs

   Let's abbreviate these databases as classEntries, nameEntries,
   methodSigEntries, and nameAndTypeEntries respectively.

   All of these databases are instantiated as const data structures in
   romjavaAux.c which is generated by the romizer.  Most (if not all)
   of the code responsible for emitting these databases in romjavaAux.c
   is in jcc/runtime/CVMWriter.java.

   However, there is a way to expand these databases with additional
   entries in RAM.  This additional entries are stored in segments.
   Runtime (as opposed to romizer time) created typeIDs are stored in
   these RAM segments.


   TypeID Segments
   ===============
   All the typeID databases are organized as chunky arrays consisting of
   the following segment types respectively:

   1. CVMtypeidClassSegment       - holds class entries
   2. CVMtypeidNameSegment        - holds name entries
   3. CVMtypeidMethodSigSegment   - holds methodSig entries
   4. CVMtypeidNameAndTypeSegment - holds nameAndType entries

   While the first segment in the chunky arrays are emitted as const arrays
   by the romizer, the linkage is in a RAM variable.

   When the typeID system needs to find a free entry in the databases, it will
   first try to look for one in existing segments of the database.  If one is
   found, it will be used.

   If not free entry can be found, the system will instantiate a new segment.

   Instantiating Segments + Segment Sizes
   ======================================
   The size of the next segment to be allocated in RAM is determined by the
   following values respectively for each database:

   1. CVMglobals.typeidClassSegmentSize
   2. CVMglobals.typeidNameSegmentSize
   3. CVMglobals.typeidMethodSigSegmentSize
   4. CVMglobals.typeidNameAndTypeSegmentSize

   Initially, in CVMtypeidInit(), these sizes are set to INITIAL_SEGMENT_SIZE.
   That means the very first time that a new segment is instantiated, it will
   be instantiated with size INITIAL_SEGMENT_SIZE.

   findFreeTableEntry() is responsible for instantiating the new segments.
   Each time, after instantiating a new segment, it will increase the above
   size values by a growth ratio.

   Currently, that ratio is hardcoded in findFreeTableEntry() as 3 /2 i.e.
   150%.  This means that the second segment will be able to hold
   1.5 * INITIAL_SEGMENT_SIZE entries.  The third segment to be instantiated
   will be able to hold 1.5 * 1.5 * INITIAL_SEGMENT_SIZE entries.  And so
   forth.

   Currently, all 4 databases have the same INITIAL_SEGMENT_SIZE and growth
   rate.  If desirable, the code can be changed later to allow these to
   differ to fit their respective usage profiles better.


   What's in the database?
   ======================
   The segments contain the following entry types for the respective databases:
   
   1. CVMtypeidClassEntry
   2. CVMtypeidNameEntry
   3. CVMtypeidMethodSigEntry
   4. CVMtypeidNameAndTypeEntry

   All of these entries are different in size, and are designed to contain
   different types of information.  See their definitions in typeid_impl.h
   for details of what is contained in them.


   Accessing entries in databases
   ==============================
   We said earlier that the databases are essentially chunky arrays.  However,
   these arrays are not even in size (as discussed in "Segment Sizes" above).

   Therefore, each entry has an array index.  Conceptually, to access the
   entry, we just index to the array.  For example:

       myClassEntry = CVMtypeidClassEntries[myClassEntryIndex]

   However, because the array is chunky, we need to use a function to do the
   indexing into the segments.  That function is indexSegmentedTable().  For
   each of the databases, there are 4 convenience wrapper macros that call
   this function on their behalf:

   1. indexClass()
   2. indexName()
   3. indexMethodSig()
   4. indexNameAndType()


   Which typeID goes into which database?
   =====================================
   classIDs are effectively indexes into CVMtypeidClassEntries and corresponds
   to a CVMtypeidClassEntry record.

   fieldIDs are built from nameIDs and sigIDs:

       The field nameIDs are indexes into CVMtypeidNameEntries and corresponds
       to a CVMtypeidNameEntry record.

       The field sigID is a classID, because fields are labels for instances
       of classes (or you can think of it that way).  Hence, they are indexes
       into CVMtypeidClassEntries and corresponds to a CVMtypeidClassEntry
       record.

       NOTE: this means that classIDs and field sigIDs share the same namespace
       (are located in the same database) and are not independent of each other.

   methodIDs are built from nameIDs and sigIDs:

       The method nameIDs are indexes into CVMtypeidNameEntries and corresponds
       to a CVMtypeidNameEntry record.

       NOTE: this means that method nameIDs and field nameIDs share the same
       namespace (are located in the same database) and are not independent
       of each other.

       The method sigID is an index into CVMtypeidMethodSigEntries and
       corresponds to a CVMtypeidMethodSigEntry record.

   What about the nameAndTypeEntries?
   =================================
   Conceptually, every fieldID and methodID corresponds to a nameAndTypeEntry.
   The nameAndTypeEntry serves to hold the pair of nameID and sigID as
   described above.

   However, in practice, that is not always the case.  First, let's look at the
   classID and memberID tokens ...

   The classID Token
   =================
   classIDs are CVMSimpleTypeIDs which ultimately contains a token of type
   CVMTypeIDToken which is an integer type.  For 32 bit typeIDs, the
   CVMTypeIDToken is 32 bits in size.

   The classID token's bit structure is as follows:

             arrayDepth  baseType
       bits       8         24

   where ...

       baseType is the classID for a non-array type.  That means that for
       non-array types, the arrayDepth field is always 0.  The baseType
       is a true index into CVMtypeidClassEntries.

       arrayType is the array depth of the array type.  8 bits allows us
       a max depth of 255.  This happens to be the max array depth allowed
       the VM spefication.

       Hence, array types don't actually have an entry in the classEntries
       database.  The array type classID is represented by a baseType
       classID which has an entry in the classEntries database.  And in
       addition, the array type classID has a non-zero value in the
       arrayDepth field indicating the depth of the array.
       
   The memberID Token
   ==================
   memberIDs (i.e. fieldIDs and methodIDs) are represented by
   CVMCompositeTypeID structs.  For the 32 bit typeID system, we want to
   keep the tokens as 32 bit values.  Note that the size of the
   CVMCompositeTypeID struct would be 64 bit in this case.

   Hence, the memberID token is represented in 2 forms:
   1. small memberIDs
   2. big memberIDs

   Small memberID Tokens
   =====================
   The small memberID tokens are encoded as follows:

              name   arrayDepth   baseType   marker
       bits    16         2           13        1

   where ...

       marker is a bit that, if set, indicates that the memberID token is of
       the small memberID encoding (above) as opposed to the big memberID
       encoding below.

       baseType maps to the lower 12 bits of the sigID component of the
       memberID.

       arrayDepth maps to bit 24 and 25 of the sigID component of the memberID.

       name maps to the lower 17 bits of the nameID component of the memberID.

   For fieldIDs, the arrayDepth and baseType fields correspond to a subset of
   the classID token which represents the field's type.

   For methodIDs, arrayDepth and baseType has no meaning.  However, small
   methodID tokens are encoded in the same pattern as small fieldID tokens for
   consistency.  Otherwise, another marker bit will be needed to distinguish
   between the 2 encodings.  You can think of the arrayType and baseType
   labels merely as names of bit regions in the method sigID.

   And yes, for methodIDs, it makes no sense to favor bit 24-25 of the sigID
   unlike for fieldIDs which uses it for array depths.  But that is the cost
   of consistency.

   In case it wasn't clear, small methodIDs are encoded and decoded using the
   exact same algorithm as small fieldIDs.  Therefore, the method sigIDs will
   be torn apart into 2 parts: bits 24-25, and bits 0-12.  These 2 parts will
   be encoded into the small memberID as if they are the arrayDepth and
   baseType of a classID.

   Big memberID Tokens
   ===================
   The big memberID tokens are encoded as the address of a CVMCompositeTypeID
   struct.  Which compositeID struct?  Well, the one in the nameAndTypeEntry.

   Hence, when a big memberID token is needed, a nameAndTypeEntry is created
   in the nameAndTypeEntries database to represent the nameID and sigID pair.
   The nameAndTypeEntry struct has a CVMCompositeTypeID field.  The address
   of that field is taken as the big memberID token.

   Note: nameAndTypeEntry structs actually tracks the bit patterns in
   nameID and sigID tokens, and not the fieldIDs or methodIDs that they
   correspond to.  Hence, if a fieldID and methodID both have identical
   nameID and sigID token values, they can share the same nameAndTypeEntry.

   This sharing not a problem because fieldIDs and methodIDs are conceptually
   in different namespaces.  You should never compare a fieldID and methodID
   and expect to be able to tell them apart.  Hence, they can afford to
   share the same namespace without collision problems.

   Why have small memberID tokens at all?
   =====================================
   Big memberID tokens require a nameAndTypeEntry struct.  This consumes
   memory.  If the values of the memberID's nameID and sigID tokens are small
   enough, it is possible to encode the memberID token completely in a 32 bit
   integer value instead of requiring memory to store the nameID and sigID
   token values.  Hence, the small memberID token was created.

   Why 17-2-12-1?
   =============
   Yeah, why not have 15, 2, 14, 1 bits (or any other permutation) for the
   small memberID token bit fields?  The answer is because some profiling has
   shown that the number of field names that are loaded by the VM exceeded
   the number of class names by a factor of about 23.

   Hence, using a 17-2-12-1 distribution gives us 32 times more room for
   nameIDs than classIDs.  This increases the probability of avoiding the
   need of a big memberID token and memory for a corresponding
   nameAndTypeEntry.

   If it can be demonstrated that a different bit ratio is more efficient,
   then the shift and bit mask values in the following places should be
   changed to match accordingly:

   1. referenceNameAndType() in typeid.c
   2. CVMtypeidGetMemberName() in typeid.h
   3. CVMtypeidGetMemberTypeX() in typeid.h
   4. vm.CVMNameAndTypeEntry.lookupEnter() in jcc/vm/CVMNameAndTypeEntry.java

*/


#ifdef CVM_TYPEID_IS_STRONGLY_TYPED

const CVMSimpleTypeID CVM_SIMPLE_TYPEID_ERROR =
                         CVM_INIT_SIMPLE_TYPEID(CVM_TYPEID_ERROR);

/* Purpose: Converts a token into a CVMClassTypeID.
   Ideally, this should be an inlined function.  It is expressed here as a
   static so that it can be inlined into the caller.  It cannot be expressed
   as a macro because it needs to define a classID local var for use in the
   conversion.
 */
CVMClassTypeID
CVMtypeidToken2ClassID(CVMTypeIDToken token)
{
    CVMClassTypeID classID;
    CVMtypeidSetToken(classID, token);
    return classID;
}
#endif

#define isTableEntry(_token) \
    (CVMtypeidTokenIsBigArray(_token) ||  \
     (((_token) > CVMtypeidLastPrimitive) && \
      ((_token) < (1 << CVMtypeidArrayShift))))


static CVMBool
CVMtypeidPrivateFieldTypeToCString(CVMTypeIDToken classToken, char* buf,
                                   int bufLength, CVMBool isField);
#define CVMtypeidTokenToCString CVMtypeidPrivateFieldTypeToCString


/*
 * A limitation of the implementation
 * Since method sig table is private, no need to expose this.
 */
#ifdef CVM_16BIT_TYPEID
#define CVM_TYPEID_MAX_SIG 0xfffe
#else
#define CVM_TYPEID_MAX_SIG 0xfffffffe
#endif


/**************************************************************
 * The same scheme of variable-length tables are used several
 * places: for CVMtypeidNameEntries, for both field and method types.
 * The same indexation idiom is used throughout. If this were Java
 * we'd use subclassing or something to share. Here, we use type casting.
 */

typedef struct genericTableHeader genericTableHeader;
struct genericTableHeader {
    SEGMENT_HEADER( struct genericTableSegment )
};

typedef struct genericTableSegment genericTableSegment;
struct genericTableSegment {
    SEGMENT_HEADER( struct genericTableSegment )
    char	genericData[1];
};

typedef struct genericTableEntry genericTableEntry;
struct genericTableEntry {
    COMMON_TYPE_ENTRY_HEADER
};

#ifdef CVM_DEBUG
static struct idstat{
    int nNamesAdded;
    int nNamesDeleted;
    int nClassesAdded;
    int nClassesDeleted;
    int nArraysAdded;
    int nArraysDeleted;
    int nPkgAdded;
    int nPkgDeleted;
    int nMethodSigsAdded;
    int nMethodSigsDeleted;
    int nMethodFormsAdded;
    int nMethodFormsDeleted;
    int nMethodDetailsAdded;
    int nMethodDetailsDeleted;
}idstat = {0,0,0,0,0,0,0,0,0,0,0,0,0,0};

static const char * const idstatName[] = {
    "member names added:",
    "           deleted:",
    "  class id's added:",
    "           deleted:",
    "  array id's added:",
    "           deleted:",
    "    packages added:",
    "           deleted:",
    " method sigs added:",
    "           deleted:",
    "  terse sigs added:",
    "           deleted:",
    " sig details added:",
    "           deleted:",
    NULL
};

void CVMtypeidPrintStats(){
    int i;
    const char * name;
    int * val = (int*)&idstat;
    CVMconsolePrintf("Name and Type ID info changed:\n");
    for ( i=0; (name = idstatName[i]) != NULL; i++ ){
	CVMconsolePrintf("    %s %d\n", name, val[i]);
    }
    memset( &idstat, 0, sizeof(idstat));
}

#endif

static void deletePackage( struct pkg * );
static int getSignatureInfo(CVMTypeIDMethodSigEntry *mp, CVMUint32 **formp,
                            CVMTypeIDToken** detailp);

/*
 * We allocate segments bigger and bigger as we go.
 * Initial RAM allocation is modest.
 */
#define INITIAL_SEGMENT_SIZE	1000

#define ASSERT_LOCKED \
    CVMassert(CVMreentrantMutexIAmOwner(CVMgetEE(),  \
                  CVMsysMutexGetReentrantMutex(&CVMglobals.typeidLock)))

/*
 * If we run out of memory or of table space, we want to throw an exception.
 * However, this can only be done with the typeidLock unlocked. Bracket the
 * throwing by conditional unlock/lock calls. They will usually be necessary.
 * (Also, since these errors seldom occur, we won't bother passing ee around just
 * for this case, but instead fetch it: locally more expensive, globally cheaper.)
 * OBVIOUSLY, make sure that the table is in a consistent state before unlocking!
 */
static void
unlockThrowInternalError( const char * msg ){
    CVMExecEnv * ee   = CVMgetEE();
    CVMBool lockOwner = CVMsysMutexIAmOwner(ee, &CVMglobals.typeidLock );
    if ( lockOwner ){
	CVMsysMutexUnlock(ee, &CVMglobals.typeidLock );
    }
    CVMthrowInternalError( ee, msg );
    if ( lockOwner ){
	CVMsysMutexLock(ee, &CVMglobals.typeidLock );
    }
}

static void
unlockThrowOutOfMemoryError(){
    CVMExecEnv * ee   = CVMgetEE();
    CVMBool lockOwner = CVMsysMutexIAmOwner(ee, &CVMglobals.typeidLock );
    if ( lockOwner ){
	CVMsysMutexUnlock(ee, &CVMglobals.typeidLock );
    }
    CVMthrowOutOfMemoryError( ee, NULL );
    if ( lockOwner ){
	CVMsysMutexLock(ee, &CVMglobals.typeidLock );
    }
}

static void
unlockThrowNoClassDefFoundError(const char * name) {
    CVMExecEnv * ee = CVMgetEE();
    CVMBool lockOwner = CVMsysMutexIAmOwner(ee, &CVMglobals.typeidLock );
    if ( lockOwner ) {
        CVMsysMutexUnlock(ee, &CVMglobals.typeidLock );
    }
    CVMthrowNoClassDefFoundError( ee, name);
    if ( lockOwner) {
        CVMsysMutexLock(ee, &CVMglobals.typeidLock );
    }
}

/*
 * Little routines used in all the ToCString routines,
 * in an attempt not to overrun externally-allocated buffers.
 * (This was a macro, but that seems the wrong space/time tradeoff.)
 */
static void conditionalPutchar( char **chrp, int * lengthRemaining, char chr, CVMBool *success  )
{
    if ( *lengthRemaining > 1 ){ 
	*(*chrp)++ = chr; 
	*lengthRemaining -= 1; 
    } else { 
	**chrp = '\0'; 
	*success = CVM_FALSE; 
	*lengthRemaining = 0; 
    }
}

static void conditionalPutstring(
    char ** chrp, int * lengthRemaining, const char *string, int stringLength, CVMBool * success )
{
    int localLengthRemaining = *lengthRemaining;
    if (localLengthRemaining <= 1) {
	**chrp = '\0'; 
	*success = CVM_FALSE; 
	*lengthRemaining = 0; 
	return;
    }
    if ( stringLength < localLengthRemaining ){
	strncpy( *chrp, string, stringLength+1 );
	*chrp += stringLength;
	*lengthRemaining -= stringLength;
    } else {
	strncpy( *chrp, string, localLengthRemaining-1 );
	*chrp += localLengthRemaining-1;
	**chrp = '\0';
	*success = CVM_FALSE;
	*lengthRemaining = 0;
    }
}

#define BASETYPE_CASES \
    case CVM_TYPEID_VOID:  conditionalPutchar(&chp, &bufLength, 'V', &success); break; \
    case CVM_TYPEID_INT:   conditionalPutchar(&chp, &bufLength, 'I', &success); break; \
    case CVM_TYPEID_SHORT: conditionalPutchar(&chp, &bufLength, 'S', &success); break; \
    case CVM_TYPEID_CHAR:  conditionalPutchar(&chp, &bufLength, 'C', &success); break; \
    case CVM_TYPEID_LONG:  conditionalPutchar(&chp, &bufLength, 'J', &success); break; \
    case CVM_TYPEID_BYTE:  conditionalPutchar(&chp, &bufLength, 'B', &success); break; \
    case CVM_TYPEID_FLOAT: conditionalPutchar(&chp, &bufLength, 'F', &success); break; \
    case CVM_TYPEID_DOUBLE:conditionalPutchar(&chp, &bufLength, 'D', &success); break; \
    case CVM_TYPEID_BOOLEAN: conditionalPutchar(&chp, &bufLength, 'Z', &success); break;


/*
 * Initialize the type Id system
 * Register some well-known typeID's 
 */
CVMBool
CVMtypeidInit( CVMExecEnv *ee )
{
    CVMglobals.typeidClassSegmentSize = INITIAL_SEGMENT_SIZE;
    CVMglobals.typeidMethodSigSegmentSize = INITIAL_SEGMENT_SIZE;
    CVMglobals.typeidNameSegmentSize = INITIAL_SEGMENT_SIZE;
    CVMglobals.typeidNameAndTypeSegmentSize = INITIAL_SEGMENT_SIZE;

    CVMglobals.initTid = 
	CVMtypeidLookupMethodIDFromNameAndSig(ee, "<init>", "()V");
    CVMglobals.clinitTid = 
	CVMtypeidLookupMethodIDFromNameAndSig(ee, "<clinit>", "()V");
    CVMglobals.finalizeTid = 
	CVMtypeidLookupMethodIDFromNameAndSig(ee, "finalize", "()V");
    CVMglobals.cloneTid = 
	CVMtypeidLookupMethodIDFromNameAndSig(ee, "clone",
                                              "()Ljava/lang/Object;");

#ifdef CVM_DEBUG_STACKTRACES
    CVMglobals.printlnTid =
	CVMtypeidLookupMethodIDFromNameAndSig(ee, "println", 
					   "(Ljava/lang/String;)V");
#endif
#ifdef CVM_DUAL_STACK
    {
        const char *midpImplLoaderName = 
            "sun/misc/MIDPImplementationClassLoader";
        const char *midletLoaderName = 
            "sun/misc/MIDletClassLoader";
        CVMglobals.midpImplClassLoaderTid = CVMtypeidNewClassID(
            ee, midpImplLoaderName, strlen(midpImplLoaderName));
        CVMglobals.midletClassLoaderTid = CVMtypeidNewClassID(
            ee, midletLoaderName, strlen(midletLoaderName));
        if (CVMtypeidIsSameClass(CVMglobals.midpImplClassLoaderTid,
				 CVM_CLASS_TYPEID_ERROR) ||
            CVMtypeidIsSameClass(CVMglobals.midletClassLoaderTid,
				 CVM_CLASS_TYPEID_ERROR))
	{
            return CVM_FALSE;
        }
    }
#endif
    return CVM_TRUE;
}

/*
 * A second stage of type ID initialization.
 * Register all pre-loaded packages using
 * CVMpackagesAddPackageEntry( pkgName, strlen(pkgName), "<preloaded>" )
 */
extern void
CVMtypeidRegisterPreloadedPackages(){
    struct pkg ** hashbucket;
    struct pkg *  pkgp;
    int i;
    size_t maxLength = 0;
    char * buffer;

    for ( i = 1; i < NPACKAGEHASH; i++ ){
	hashbucket = &CVM_pkgHashtable[ i ];
	for ( pkgp = *hashbucket; pkgp != NULL; pkgp = pkgp->next ){
	    size_t l = strlen( pkgp->pkgname );
	    if ( l > maxLength ) maxLength = l;
	}
    }
    buffer = (char *)malloc( maxLength + 2 );
    if ( buffer == NULL ) return;

    for ( i = 1; i < NPACKAGEHASH; i++ ){
	hashbucket = &CVM_pkgHashtable[ i ];
	for ( pkgp = *hashbucket; pkgp != NULL; pkgp = pkgp->next ){
	    if ( pkgp->pkgname[0] != '\0' ){
		size_t l = strlen( pkgp->pkgname );
		strncpy( buffer, pkgp->pkgname, l );
		buffer[l] = '/'; /* makes  CVMpackagesAddEntry happy */
		buffer[l+1] = '\0';
		CVMpackagesAddEntry( buffer, "<preloaded>" );
	    }
	}
    }
    free( buffer );
}

struct genericTableSegment;

static void  processSegmentedTable(
    struct genericTableSegment * thisSeg, 
    size_t			 entrySize,
    void   (*entryCallback)(void*),
    void   (*segmentCallback)(void*) );

/*
 * Callbacks for giving back memory.
 */
static void destroyClassEntry(void * t)
{
    CVMTypeIDClassEntry *p = (CVMTypeIDClassEntry *)t;
    if (p->tag == CVM_TYPE_ENTRY_OBJ) {
	free((void*)(p->value.className.classInPackage)); /*cast away const */
	p->value.className.classInPackage = NULL;
    }
}

static void destroyNameEntry(void *t)
{
    CVMTypeIDNameEntry *p = (CVMTypeIDNameEntry *)t;
    free((void*)(p->name)); /*cast away const*/
    p->name = NULL;
}

static void destroyMethodSigEntry(void *t)
{
    CVMTypeIDMethodSigEntry *p = (CVMTypeIDMethodSigEntry *)t;
    CVMTypeIDToken *detailp;
    int nDetail;
    nDetail = getSignatureInfo(p, NULL, &detailp);
    if ( nDetail > NUMBER_OF_METHOD_INLINE_DETAILS){
	p->form.formp = NULL; /* dead for sure */
	free( detailp );
    }
}

static void destroySegment( void * ); /* see later */

/*
 * Give back memory. Leaves a mess, as we don't
 * neatly unlink things!
 */
void
CVMtypeidDestroy( ){
    /*
     * Destroy signatures first, as they depend
     * on forms for interpretation. Then do other tables.
     */
    struct sigForm *thisSig, *nextSig;
    struct pkg     *thisPkg, *nextPkg;
    int i;

    processSegmentedTable(
	(genericTableSegment*)&CVMtypeidMethodSigEntries,
	sizeof(CVMTypeIDMethodSigEntry),
	destroyMethodSigEntry, destroySegment);
    processSegmentedTable(
	(genericTableSegment*)&CVMtypeidClassEntries,
	sizeof(CVMTypeIDClassEntry),
	destroyClassEntry, destroySegment );
    processSegmentedTable(
	(genericTableSegment*)&CVMtypeidNameEntries,
	sizeof(CVMTypeIDNameEntry),
	destroyNameEntry, destroySegment );
    /*
     * fields are on a single linked list.
     * Assume that any with max ref count are in Rom.
     */
    nextSig = *CVMformTablePtr;
    while ( nextSig != NULL && (nextSig->refCount) != MAX_COUNT ){
	thisSig = nextSig;
	nextSig = thisSig->next;
	free( thisSig );
    }
    /*
     * packages are on multiple lists. There is an INROM flag for them.
     */
    for ( i = 0 ; i < NPACKAGEHASH; i++ ){
	nextPkg = CVM_pkgHashtable[i];
	while ( nextPkg != NULL ){
	    thisPkg = nextPkg;
	    nextPkg = thisPkg->next;
	    if ( thisPkg->state != TYPEID_STATE_INROM ){
		free( thisPkg );
	    }
	}
    }
}

/****************************************************************
 * A simple name hashing function.
 * It is used in a bunch of places for turning names into numbers
 * It must be EXACTLY the same as the one used in JavaCodeCompact to
 * build the initial type tables, else we'll never find the entries!
 */

static unsigned computeHash( const char * name, int l ){
    /*
     * Since suffix is more likely to be unique,
     * hash from the back end.
     */
    const unsigned char * s = (const unsigned char *)name;
    unsigned v = 0;
    int n = ( l > 7 ) ? 7 : l;
    s += l-n;
    while ( n--> 0 ){
	v = (v*19) + s[n] - '/';
    }
    return v;
}

static void  processTableSegment(
    struct genericTableSegment * thisSeg, 
    size_t			 entrySize,
    void   (*callback)(void*)
){
    int i, n;
    char *   thisEntry;
    n = thisSeg->numEntriesInSegment;
    if ( thisSeg->nextFree >= 0 )
	n = thisSeg->nextFree;
    thisEntry = &(thisSeg->genericData[0]);
    for ( i = 0; i < n; i++ ){
#ifndef NO_RECYCLE
	if ( ((struct genericTableEntry*)thisEntry)->refCount != 0 )
#endif
	    callback(thisEntry);
	thisEntry += entrySize;
    }
}

/*
 * Iterate over all dynamically-allocated objects in the table.
 * Used to give back memory!
 */
static void  processSegmentedTable(
    struct genericTableSegment * thisSeg, 
    size_t			 entrySize,
    void   (*entryCallback)(void*),
    void   (*segmentCallback)(void*)
) {
    struct genericTableSegment * nextSeg; 
    /* in all cases, the first segment is part of the preloaded
     * image and we want to skip it.
     * thus start at the second one.
     */
    nextSeg = *(thisSeg->next);
    while ( nextSeg != NULL ){
	thisSeg = nextSeg;
	nextSeg = *(thisSeg->next);
	processTableSegment( thisSeg, entrySize, entryCallback );
	segmentCallback( thisSeg );
    }
}

static void destroySegment( void * t){
    struct genericTableSegment *p = (struct genericTableSegment *)t;
    p->numberOfFreeEntries = 0;
    p->nextFree = -1;
    p->next = 0;
    free( p );
}

/* Purpose: Index into the chunky array specified by thisSeg, and return the
   address of the entry at that index.  Essentially,

       result = thisSeg[indexVal]

   where each entry is of size entrySize.
*/
/*
 * This has a NoCheck version for those rare occasions
 * that its ok to reference an entry with a zero refCount
 * (Could always distribute the assertion to all clients, but
 * that is more error-prone than this.)
 */
static void *indexSegmentedTable(CVMTypeIDToken indexVal,
                                 genericTableSegment **returnSeg,
                                 genericTableSegment *thisSeg, 
                                 size_t	entrySize)
{
    genericTableEntry *thisEntry = NULL;
    if (indexVal >= TYPEID_NOENTRY) {
        if (returnSeg != NULL) {
            *returnSeg = NULL; /* not a valid index, so return NULL */
        }
        return NULL;
    }
    CVMassert(indexVal >= thisSeg->firstIndex);

    /* Scan through the segments and find the one that contains the entry that
       the index corresponds to: */
    indexVal -= thisSeg->firstIndex;

    /* TODO: Note that thisSeg is dereferenced below to compute the address
       of its genericData field, as well as in the refCount > 0 assertion.
       These would imply that this while loop should never terminate with a
       NULL thisSeg.  Investigate this later, and see if this (thisSeg == NULL)
       condition can be eliminated, and the (thisSeg != NULL) assertion below
       added.
    */
    while (/* (thisSeg != NULL) && */(indexVal >= thisSeg->numEntriesInSegment)) {
	indexVal -= thisSeg->numEntriesInSegment;
	thisSeg = *(thisSeg->next);
        /* TODO: consider adding the following assert here: */
        CVMassert(thisSeg != NULL);
        /* */
    }

    thisEntry = (genericTableEntry *)&thisSeg->genericData[indexVal*entrySize];
    CVMassert(thisEntry->refCount > 0);

    if (returnSeg != NULL) {
	*returnSeg = thisSeg;
    }
    return thisEntry;
}

#ifdef CVM_DEBUG_ASSERTS

static void *indexSegmentedTableNoCheck(CVMAddr indexVal,
                                        genericTableSegment **returnSeg,
                                        genericTableSegment *thisSeg,
                                        size_t entrySize)
{
    genericTableEntry *thisEntry;
    if (indexVal >= TYPEID_NOENTRY) {
        if (returnSeg != NULL) {
            *returnSeg = NULL; /* not a valid index, so return NULL */
        }
        return NULL;
    }
    CVMassert(indexVal >= thisSeg->firstIndex);

    /* Scan through the segments and find the one that contains the entry that
       the index corresponds to: */
    indexVal -= thisSeg->firstIndex;

    /* NOTE: indexSegmentedTableNoCheck() originate with a cut-and-paste of
       indexSegmentedTable() above.  See the TODO there.  The (thisSeg != NULL)
       was successfully removed from here without causing any problems.  So
       we went ahead and eliminated it here.
    */
    while (indexVal >= thisSeg->numEntriesInSegment) {
	indexVal -= thisSeg->numEntriesInSegment;
	thisSeg = *(thisSeg->next);
        CVMassert(thisSeg != NULL);
    }
    thisEntry = (genericTableEntry *)&thisSeg->genericData[indexVal*entrySize];
    /* CVMassert(thisEntry->refCount > 0); <== THIS IS THE KEY DIFFERENCE from
                                               indexSegmentedTable(). */
    if (returnSeg != NULL) {
	*returnSeg = thisSeg;
    }
    return thisEntry;
}
#else

#define indexSegmentedTableNoCheck indexSegmentedTable

#endif

/* The specializations of the above */

#define indexMethodSig(index, segp) \
    ((CVMTypeIDMethodSigEntry *)indexSegmentedTable(index, \
	segp, \
	(genericTableSegment*)&CVMtypeidMethodSigEntries, \
	sizeof(CVMTypeIDMethodSigEntry)))

#define indexMethodSigNoCheck(index, segp) \
    ((CVMTypeIDMethodSigEntry *)indexSegmentedTableNoCheck(index, \
	segp, \
	(genericTableSegment*)&CVMtypeidMethodSigEntries, \
	sizeof(CVMTypeIDMethodSigEntry)))

#define indexClass(index, segp) \
    ((CVMTypeIDClassEntry *)indexSegmentedTable(index, \
        segp, \
	(genericTableSegment*)&CVMtypeidClassEntries, \
	sizeof(CVMTypeIDClassEntry)))

#define indexClassNoCheck(index, segp) \
    ((CVMTypeIDClassEntry *)indexSegmentedTableNoCheck(index, \
	segp, \
	(genericTableSegment*)&CVMtypeidClassEntries, \
	sizeof(CVMTypeIDClassEntry)))

#define indexName(index, segp) \
    ((CVMTypeIDNameEntry *)indexSegmentedTable(index, \
	segp, \
	(genericTableSegment*)&CVMtypeidNameEntries, \
	sizeof(CVMTypeIDNameEntry)))

#define indexNameNoCheck(index, segp) \
    ((CVMTypeIDNameEntry *)indexSegmentedTableNoCheck(index, \
	segp, \
	(genericTableSegment*)&CVMtypeidNameEntries, \
	sizeof(CVMTypeIDNameEntry)))

#define indexNameAndType(index, segp) \
    ((CVMTypeIDNameAndTypeEntry *)indexSegmentedTable(index, \
	segp, \
	(genericTableSegment*)&CVMtypeidNameAndTypeEntries, \
	sizeof(CVMTypeIDNameAndTypeEntry)))

#define indexNameAndTypeNoCheck(index, segp) \
    ((CVMTypeIDNameAndTypeEntry *)indexSegmentedTableNoCheck(index, \
	segp, \
	(genericTableSegment*)&CVMtypeidNameAndTypeEntries, \
	sizeof(CVMTypeIDNameAndTypeEntry)))

/*
 * Remove an entry from an index'ed hash chain.
 * Also note it as free in its containing segment.
 */
static void
unlinkEntry(CVMTypeIDToken oldCookie,
            CVMTypeIDToken replacementCookie,
            CVMTypeIDToken *linkp,
            genericTableSegment *thisTable,
            genericTableSegment *thisSeg,
            size_t entrySize)
{
    CVMTypeIDToken indexCookie;
    genericTableEntry *thisEntry;

    /* Find the node entry in the list that has the cookie value of oldCookie: */
    while ((indexCookie = *linkp) != oldCookie) {
	CVMassert(indexCookie != TYPEID_NOENTRY);
        /* Compute thisEntry = thisTable[indexCookie]: */
	thisEntry = (struct genericTableEntry *)
            indexSegmentedTable(indexCookie, NULL, thisTable, entrySize);
	linkp = & (thisEntry->nextIndex);
    }
    *linkp = replacementCookie;
    if (thisSeg == NULL) {
	/* containing segment not actually known. Do one more index to get it */
	/* and since this entry is known to have a zero ref-count... */
	indexSegmentedTableNoCheck(oldCookie, &thisSeg, thisTable, entrySize);
    }
    thisSeg->numberOfFreeEntries += 1;
}

/* Purpose: Finds an empty slot in a generic type database.  This function
   is used by findFreeNameEntry(), findFreeClassEntry(), and
   findFreeMethodSigEntry() to search their respective databases for
   free entry slots.
*/
static void *
findFreeTableEntry(genericTableSegment *initialSeg,
                   size_t entrySize,
                   CVMUint32 *tableAllocationCount,
                   CVMTypeIDToken *newIndex)
{
    genericTableSegment *nextSeg = initialSeg;
    genericTableSegment *thisSeg;
    genericTableEntry   *thisEntry;
    genericTableEntry   *endEntry;
    size_t               allocationSize;
    size_t               newIndexVal;

    ASSERT_LOCKED;

    /* Look through the database segments and see if there are any free slots
       in any of them.  If one is found, then go to findFreeInSegment to
       make use of that slot: */
    do {
	thisSeg = nextSeg;
#ifdef NO_RECYCLE
	if (thisSeg->nextFree >= 0) goto findFreeInSegment;
#else
	if (thisSeg->numberOfFreeEntries > 0) goto findFreeInSegment;
#endif
    } while ((nextSeg = *(thisSeg->next)) != NULL);

    /* If we get here, then we weren't able to find any pre-existing free
       slots in the existing segments.  Hence, we'll attempt to allocate
       a new segment:
    */
    allocationSize = sizeof(genericTableHeader)
                   + (*tableAllocationCount * entrySize)
                   + sizeof(genericTableSegment *);

    nextSeg = (genericTableSegment*)malloc(allocationSize);
    if ( nextSeg == NULL ){
	/* malloc failure. Return appropriately null values. */
	/* Must return TYPEID_NOENTRY here -- not CVM_TYPEID_ERROR */
	*newIndex = TYPEID_NOENTRY;
	unlockThrowOutOfMemoryError();
	return NULL;
    }

    /* At this point, thisSeg would be pointing to the last segment in the
       list.  Add this newly allocated segment to the end: */
    *(thisSeg->next) = nextSeg;

    /* The next typeID value starts pass the last one from the last segment: */
    nextSeg->firstIndex = thisSeg->firstIndex + thisSeg->numEntriesInSegment;
    /* The number of slots (which are all free initially) in this segment is
       the number that we allocated for the segment: */
    nextSeg->numEntriesInSegment =
        nextSeg->numberOfFreeEntries = *tableAllocationCount;
    /* The next free slot in this segment is the first slot: */
    nextSeg->nextFree = 0;

    thisSeg = nextSeg;
    /* new next-pointer cell follows the segment immediately */
    thisSeg->next = (genericTableSegment**) 
	(((char*)thisSeg) + allocationSize - sizeof(genericTableSegment *));
    *(thisSeg->next) = NULL;

    /* Increase the size of the next table to be allocated by 50%: */
    *tableAllocationCount = (*tableAllocationCount * 3) / 2;

findFreeInSegment:
    /* If we get here, then we have found a segment with an available free
       slot.
    */
    if (thisSeg->nextFree >= 0) {
	/* new allocation. just bump and go. */
	thisEntry = (genericTableEntry*)
            &thisSeg->genericData[thisSeg->nextFree * entrySize];

        /* Set up the nextFree pointer for the next typeID allocation: */
        thisSeg->nextFree++;
	if (thisSeg->nextFree >= thisSeg->numEntriesInSegment) {
	    thisSeg->nextFree = -1; /* no more easy ones in this segment */
        }

    }else{
	/* look for a free table entry the hard way */
	endEntry = (struct genericTableEntry*)
            &thisSeg->genericData[thisSeg->numEntriesInSegment * entrySize];

        /* Do a linear search through the table to find an slot that is not
           in use as indicated by a reference count of 0: */
	for (thisEntry = (genericTableEntry*)&thisSeg->genericData[0];
             thisEntry < endEntry;
             thisEntry = (genericTableEntry*)((char*)thisEntry + entrySize)) {
	    if (thisEntry->refCount == 0)
		break;
	}
	CVMassert(thisEntry < endEntry);
        CVMassert(thisEntry->refCount == 0);
    }
    /* thisEntry now points to a free one. */
    thisEntry->refCount = 1;
    thisSeg->numberOfFreeEntries -= 1;
    newIndexVal = thisSeg->firstIndex
	+ ((char*)thisEntry - (char*)&(thisSeg->genericData[0])) / entrySize;
    *newIndex = (CVMTypeIDToken)newIndexVal;
    return thisEntry;
}

#ifdef CVM_DEBUG

struct tableReferenceMap {
    int 	minIndex;
    int 	maxTableSize;
    CVMUint32*	bitMap;
    CVMBool	failure;
    const char* tableName;
    struct pkg* currentPackage; /* only sometimes interesting */
    int		nForms;
    int *	formRefCount;
};

typedef CVMBool (*checkSegmentedTableCallback)(
	CVMUint32 hashval,
	CVMUint32 indexval,
	void * thisEntry,
	void * thisSegment,
	struct tableReferenceMap * tmap );

static void
tableError(const char * tableName,
	int hashno,
	int next,
	struct genericTableEntry * thisEntry,
	CVMBool initialHashEntry,
	const char * errorType )
{
    CVMconsolePrintf("Error in typeid table %s:\n", tableName );
    CVMconsolePrintf("	%s ", errorType );
    if ( initialHashEntry ){
	CVMconsolePrintf(" in hashtable at entry %d\n", hashno );
    } else {
	CVMconsolePrintf(" in entry %d on hash chain %d\n", next, hashno );
	if ( thisEntry!= NULL){
	    CVMconsolePrintf("  0x%x -> next: %d, refCount %d\n", thisEntry, thisEntry->nextIndex, thisEntry->refCount );
	}
    }
}

/* determine size of table and allocate bit map*/

static void initializeReferenceMap(
    struct genericTableSegment * table,
    const char * name,
    struct tableReferenceMap * mp )
{
    struct genericTableSegment* thisSegment;
    mp->maxTableSize = 0;
    mp->minIndex = table->firstIndex;
    mp->tableName = name;
    /* CVMconsolePrintf("%s table segments:\n", name); */
    for ( thisSegment=table;
	*(thisSegment->next)!=NULL;
	thisSegment=*(thisSegment->next) ){
	    /*CVMconsolePrintf("    first %d, n %d, nextFree %d\n",
		thisSegment->firstIndex,
		thisSegment->numEntriesInSegment,
		thisSegment->nextFree
	    );*/
    }
    /*CVMconsolePrintf("    first %d, n %d, nextFree %d\n",
	thisSegment->firstIndex,
	thisSegment->numEntriesInSegment,
	thisSegment->nextFree
    );*/
    mp->maxTableSize = thisSegment->firstIndex + 
	((thisSegment->nextFree>= 0)
	    ? (thisSegment->nextFree)
	    : (thisSegment->numEntriesInSegment-1));
    mp->bitMap = (CVMUint32*)calloc( sizeof(CVMUint32), (mp->maxTableSize+31)>>5 );
    mp->failure = CVM_FALSE;
    /*CVMconsolePrintf("%s table [%d ..%d]\n", name, mp->minIndex, mp->maxTableSize-1);*/
}

#undef bitVal
#undef setBit
#define bitVal(n) (mp->bitMap[(n)>>5]&(1<<((n)&31)) )
#define setBit(n) (mp->bitMap[(n)>>5] |= (1<<((n)&31)) )

static void checkReferenceMap(
    struct genericTableSegment * table, 
    size_t			 entrySize,
    checkSegmentedTableCallback  checkUnreferencedData,
    struct tableReferenceMap * mp )
{
    unsigned int i;
    struct genericTableEntry *	tableEntry;
    if ( ! mp->failure ) {
	/* now make sure that all the unreferenced entries
	 * have a zero reference count.
	 * If there's already been a failure, the bit map is
	 * incomplete and will yield false errors.
	 */
	for ( i = mp->minIndex; i < mp->maxTableSize; i++ ){
	    if ( !bitVal( i ) ){
		struct genericTableSegment * thisSegment; 
		tableEntry = (struct genericTableEntry*)
		    indexSegmentedTableNoCheck( i, &thisSegment, table, entrySize );
		if ( tableEntry->refCount != 0 ){
		    tableError( mp->tableName, 0, i, tableEntry,
			CVM_FALSE, "non-zero refCount in unreferenced entry" );
		    mp->failure = CVM_TRUE;
		}
		if ( checkUnreferencedData != NULL ){
		    checkUnreferencedData( -1, i, tableEntry, thisSegment, mp );
		}
	    }
	}
    }
    free( mp->bitMap );
}

static CVMBool
checkSegmentedTable(CVMTypeIDToken hashtabl[],
                    size_t nHash,
                    genericTableSegment *table, 
                    size_t entrySize,
                    checkSegmentedTableCallback checkData,
                    struct tableReferenceMap *mp)
{
    int                  hashno;
    CVMTypeIDToken       next;
    genericTableEntry   *thisEntry;
    genericTableEntry   *nextEntry;
    genericTableSegment *thisSegment;
    genericTableSegment *nextSegment;
    int                  minIndex;
    int                  maxTableSize;
    CVMBool              failure = CVM_FALSE;

    minIndex     = mp->minIndex;
    maxTableSize = mp->maxTableSize;
	
    /* follow all hash links */
    for ( hashno = 0; hashno < nHash; hashno++ ){
	next = hashtabl[hashno];
	thisEntry   = NULL;
	thisSegment = NULL;
	while ( next != TYPEID_NOENTRY ){
	    if ( (next < minIndex) || (next >= maxTableSize) ){
		tableError( mp->tableName, hashno, next, thisEntry,
		    thisSegment==NULL, "bad hash chain entry" );
		mp->failure = failure = CVM_TRUE;
		goto nextHashEntry;
	    }
	    nextEntry = (genericTableEntry*)
		indexSegmentedTableNoCheck( next, &nextSegment, table, entrySize );
	    if ( nextEntry == NULL ){
		tableError( mp->tableName, hashno, next, thisEntry,
		    thisSegment==NULL, "bad hash chain entry" );
		mp->failure = failure = CVM_TRUE;
		goto nextHashEntry;
	    }
	    thisEntry = nextEntry;
	    thisSegment = nextSegment;
	    if ( thisEntry->refCount == 0 ){
		tableError( mp->tableName, hashno, next, thisEntry,
		    thisSegment==NULL, "zero reference count" );
		mp->failure = failure = CVM_TRUE;
		goto nextHashEntry;
	    }
	    if ( bitVal( next ) ){
		tableError( mp->tableName, hashno, next, thisEntry,
		    thisSegment==NULL, "entry multiply listed" );
		mp->failure = failure = CVM_TRUE;
		goto nextHashEntry;
	    }
	    setBit( next );
	    if ( checkData != NULL ){
		checkData( hashno, next, thisEntry, thisSegment, mp );
	    }
	    next = thisEntry->nextIndex;
	}
	nextHashEntry:;
    }
    
    return failure;
}

/*
 * table-specific helper functions
 * just a little data-integrity checking.
 */
static CVMBool
liveName(
    CVMUint32 hashval,
    CVMUint32 indexval,
    void * thisEntry,
    void * thisSegment,
    struct tableReferenceMap * tmap )
{
    CVMTypeIDNameEntry *m = (CVMTypeIDNameEntry *)thisEntry;
    if ( m->name == NULL ){
	tableError("member name",
	hashval, indexval,
	(struct genericTableEntry *)thisEntry,
	CVM_FALSE, "null name pointer");
	return CVM_TRUE;
    }
    return CVM_FALSE;
}

static CVMBool
deadName(
    CVMUint32 hashval,
    CVMUint32 indexval,
    void * thisEntry,
    void * thisSegment,
    struct tableReferenceMap * tmap )
{
#ifndef NO_RECYCLE
    CVMTypeIDNameEntry * m = (CVMTypeIDNameEntry *)thisEntry;
    if ( m->name != NULL ){
	tableError("member name",
	    hashval, indexval,
	    (struct genericTableEntry *)thisEntry,
	    CVM_FALSE, "non-null name pointer in deleted entry");
	return CVM_TRUE;
    }
#endif
    return CVM_FALSE;
}

static CVMBool
liveScalar(
    CVMUint32 hashval,
    CVMUint32 indexval,
    void * thisEntry,
    void * thisSegment,
    struct tableReferenceMap * tmap )
{
    CVMTypeIDClassEntry *sp = (CVMTypeIDClassEntry *)thisEntry;
    CVMTypeIDClassEntry *bp;

    CVMBool hadError = CVM_FALSE;
    switch (sp->tag){
    case CVM_TYPE_ENTRY_OBJ:
	if ( sp->value.className.classInPackage == NULL ){
	    tableError("field type",
		hashval, indexval,
		(struct genericTableEntry *)thisEntry,
		CVM_FALSE, "null name pointer in classname entry");
	    hadError = CVM_TRUE;
	}
	if ( sp->value.className.package != tmap->currentPackage ){
	    tableError("field type",
		hashval, indexval,
		(struct genericTableEntry *)thisEntry,
		CVM_FALSE, "classname entry doesn't point back to its containing package");
	    hadError = CVM_TRUE;
	}
	break;
    case CVM_TYPE_ENTRY_ARRAY:
	if ( (sp->value.bigArray.depth <= CVMtypeidMaxSmallArray )
	    || (sp->value.bigArray.depth > CVM_MAX_ARRAY_DIMENSIONS ) ){
	    tableError("field type",
		hashval, indexval,
		(struct genericTableEntry *)thisEntry,
		CVM_FALSE, "out-of-range depth in array entry");
	    hadError = CVM_TRUE;
	}
	bp = indexClassNoCheck(sp->value.bigArray.basetype, NULL);
	if ( bp == NULL ){
	    tableError("field type",
		hashval, indexval,
		(struct genericTableEntry *)thisEntry,
		CVM_FALSE, "bad base-type index in array entry");
	    hadError = CVM_TRUE;
	} else if ( bp->refCount == 0 ){
	    tableError("field type",
		hashval, indexval,
		(struct genericTableEntry *)thisEntry,
		CVM_FALSE, "array base type has 0 refcount");
	    hadError = CVM_TRUE;
	} else if ( bp->tag != CVM_TYPE_ENTRY_OBJ ){
	    tableError("field type",
		hashval, indexval,
		(struct genericTableEntry *)thisEntry,
		CVM_FALSE, "array base type is not class");
	    hadError = CVM_TRUE;
	}
	break;
    default:
	tableError("field type",
	    hashval, indexval,
	    (struct genericTableEntry *)thisEntry,
	    CVM_FALSE, "bad type tag in live entry");
	hadError = CVM_TRUE;
    }
    return hadError;
}

static CVMBool
deadScalar(
    CVMUint32 hashval,
    CVMUint32 indexval,
    void * thisEntry,
    void * thisSegment,
    struct tableReferenceMap * tmap )
{
#ifndef NO_RECYCLE
    CVMTypeIDClassEntry *sp = (CVMTypeIDClassEntry *)thisEntry;
    if ( sp->tag != CVM_TYPE_ENTRY_FREE ){
	tableError("field type",
	    hashval, indexval,
	    (struct genericTableEntry *)thisEntry,
	    CVM_FALSE, "bad type tag in dead entry");
	return CVM_TRUE;
    }
#endif
    return CVM_FALSE;
}

static CVMBool
liveMethod(
    CVMUint32 hashval,
    CVMUint32 indexval,
    void * thisEntry,
    void * thisSegment,
    struct tableReferenceMap * tmap )
{
    CVMTypeIDMethodSigEntry *m = (CVMTypeIDMethodSigEntry *)thisEntry;
    if ( (m->nParameters+2) > FORM_SYLLABLESPERDATUM){
	int formno = 0;
	struct sigForm *f, *thisForm;
	thisForm = m->form.formp;
	for ( f = *CVMformTablePtr; f!= NULL; f = f->next ){
	    if ( f == thisForm )
		break;
	    else
		formno+=1;
	}
	if ( f == NULL ){
	    tableError("method type",
		hashval, indexval,
		(struct genericTableEntry *)thisEntry,
		CVM_FALSE, "bad form pointer");
	    return CVM_TRUE;
	} else {
	    tmap->formRefCount[formno] += 1;
	}
    }
    return CVM_FALSE;
}

void CVMtypeidCheckTables(){
    struct pkg * pp;
    CVMUint32 i;
    struct tableReferenceMap tmap;
    struct sigForm * f;

    tmap.currentPackage = NULL;
    tmap.nForms = 0;
    tmap.formRefCount = NULL;

    /*
     * member name table
     */
    initializeReferenceMap(
        (genericTableSegment*)&CVMtypeidNameEntries,
	"member name", &tmap );

    checkSegmentedTable(
        CVMtypeidNameHash, CVM_TYPEID_NAME_HASH_SIZE,
        (genericTableSegment*)&CVMtypeidNameEntries,
        sizeof(CVMTypeIDNameEntry), liveName, &tmap);

    checkReferenceMap(
        (genericTableSegment*)&CVMtypeidNameEntries,
        sizeof(CVMTypeIDNameEntry), deadName, &tmap);

    /*
     * method type table table
     * part of the setup is to setup for validating
     * the form reference counting.
     */
    for ( f = *CVMformTablePtr; f!= NULL; f=f->next )
	tmap.nForms += 1;
    tmap.formRefCount = (int*)calloc( tmap.nForms, sizeof(int) );
    initializeReferenceMap((genericTableSegment*)&CVMtypeidMethodSigEntries,
                           "method type", &tmap );

    checkSegmentedTable(
	CVMtypeidMethodSigHash, NMETHODTYPEHASH,
	(genericTableSegment*)&CVMtypeidMethodSigEntries,
	sizeof(CVMTypeIDMethodSigEntry),
	liveMethod, &tmap);

    checkReferenceMap(
	(genericTableSegment*)&CVMtypeidMethodSigEntries,
	sizeof(CVMTypeIDMethodSigEntry),
	NULL, &tmap);
    /* make sure the form reference counts are right */
    for ( f = *CVMformTablePtr, i=0; f!= NULL; f=f->next, i++ ){
	if ( f->refCount == MAX_COUNT )
	    continue;
	if ( f->refCount != tmap.formRefCount[i] ){
	    CVMconsolePrintf("Error in typeid form table:\n" );
	    CVMconsolePrintf("	entry at 0x%x claims %d references, but %d found\n",
		f, f->refCount, tmap.formRefCount[i] );
#ifndef NO_RECYCLE
	} else if ( f->refCount == 0 ){
	    CVMconsolePrintf("Error in typeid form table:\n" );
	    CVMconsolePrintf("	unreferenced entry at 0x%x\n", f );
#endif
	}
    }
    free( tmap.formRefCount );
    tmap.formRefCount = NULL;

    /*
     * field table
     * which is accessed by way of the pkg table.
     */
    initializeReferenceMap(
	(struct genericTableSegment*)&CVMtypeidClassEntries,
	"field type",
        &tmap );

    /* do null package, then do other packages */
    tmap.currentPackage = CVMnullPackage;
    checkSegmentedTable( CVMnullPackage->typeData,
	NCLASSHASH,
	(struct genericTableSegment*)&CVMtypeidClassEntries,
	sizeof(CVMTypeIDClassEntry),
	liveScalar, &tmap );
    for ( i = 0 ; i < NPACKAGEHASH; i++ ){
	for ( pp = CVM_pkgHashtable[i] ; pp != NULL; pp = pp-> next ){
	    tmap.currentPackage = pp;
	    checkSegmentedTable( pp->typeData,
		NCLASSHASH,
		(struct genericTableSegment*)&CVMtypeidClassEntries,
		sizeof(CVMTypeIDClassEntry),
		liveScalar, &tmap );
	}
    }

    checkReferenceMap((genericTableSegment*)&CVMtypeidClassEntries,
                      sizeof(CVMTypeIDClassEntry),
                      deadScalar, &tmap);
}

typedef void (*diffSegmentedTableCallback)(
	CVMUint32 indexval,
	void *  thisEntry,
	CVMBool verbosity );


static void findDiffsInSegmentedTable(
    struct genericTableSegment * table, 
    size_t			 entrySize,
    diffSegmentedTableCallback   diffFn,
    CVMBool			 verbosity)
{
    int entryNo;
    struct genericTableEntry *thisEntry;
    for ( ; table != NULL ; table = *(table->next) ){
	int n = (table->nextFree>=0)?table->nextFree:table->numEntriesInSegment;
	entryNo = table->firstIndex;
	thisEntry = (struct genericTableEntry*)&(table->genericData[0]);
	for ( ; n > 0; n-- ){
	    if ((thisEntry->state&~TYPEID_STATE_INROM) != 0 ){
		/* report and reset */
		diffFn( entryNo, thisEntry, verbosity );
		thisEntry->state = 0;
	    }
	    entryNo += 1;
	    thisEntry = (struct genericTableEntry *)((char*)thisEntry + entrySize);
	}
    }
}

static CVMBool
diffPrefix( int indexval, int state, CVMBool verbosity)
{
    switch ( state ){
    case TYPEID_STATE_ADDED:
	CVMconsolePrintf("	index %d: added ", indexval );
	break;
    case TYPEID_STATE_DELETED:
	CVMconsolePrintf("	index %d: deleted ", indexval );
	break;
    case TYPEID_STATE_ADDED|TYPEID_STATE_DELETED:
	if ( verbosity ){
	    CVMconsolePrintf("	index %d: added and deleted ",
		indexval );
	} else {
	    return CVM_FALSE;
	}
	break;
    }
    return CVM_TRUE;
}

static void memberDiffs(
	CVMUint32 indexval,
	void *  thisEntry,
	CVMBool verbosity )
{
    CVMTypeIDNameEntry *m = (CVMTypeIDNameEntry *)thisEntry;
    const char * mname;
    if ( ! diffPrefix( indexval, m->state, verbosity ) ) return;
    mname = m->name;
    if ( mname == NULL ) mname = "<null>";
    CVMconsolePrintf("%s(%d)\n", mname, m->refCount);
}

static void fieldDiffs(
	CVMUint32 indexval,
	void *  thisEntry,
	CVMBool verbosity )
{
    CVMTypeIDClassEntry *s = (CVMTypeIDClassEntry *)thisEntry;
    CVMTypeIDToken basecookie;
    CVMTypeIDClassEntry *b;

    if ( ! diffPrefix( indexval, s->state, verbosity ) ) return;

    switch ( s->tag ){
    case CVM_TYPE_ENTRY_OBJ:
	CVMconsolePrintf("class %s/%s(%d)",
                         s->value.className.package->pkgname,
                         s->value.className.classInPackage, s->refCount);
	break;
    case CVM_TYPE_ENTRY_ARRAY:
	CVMconsolePrintf("array depth %d of ", s->value.bigArray.depth );
	basecookie = s->value.bigArray.basetype;
	if ( isTableEntry( basecookie ) ){
	    b = indexClassNoCheck( basecookie, NULL );
	    CVMconsolePrintf("class %s/%s(%d)",
                             b->value.className.package->pkgname,
                             b->value.className.classInPackage, s->refCount);
	} else {
	    /* this cannot happen as they are all in ROM */
	    CVMconsolePrintf("simple type %d", basecookie );
	}
	break;
    default:
	CVMconsolePrintf("	unknown thing of tag %d", s->tag );
	break;
    }
    CVMconsolePrintf("\n" );
}

static void methodDiffs(
	CVMUint32 indexval,
	void *  thisEntry,
	CVMBool verbosity )
{
    CVMTypeIDMethodSigEntry *s = (CVMTypeIDMethodSigEntry *)thisEntry;

    if ( ! diffPrefix( indexval, s->state, verbosity ) ) return;

    CVMconsolePrintf("a method signature of %d parameters\n",
	s->nParameters );
}

static void formDiffs(
	struct sigForm *  thisEntry,
	CVMBool verbosity )
{
    switch ( thisEntry->state ){
    case TYPEID_STATE_ADDED:
	CVMconsolePrintf("	added ");
	break;
    case TYPEID_STATE_DELETED:
	CVMconsolePrintf("	deleted ");
	break;
    case TYPEID_STATE_ADDED|TYPEID_STATE_DELETED:
	if ( verbosity ){
	    CVMconsolePrintf("	added and deleted " );
	} else {
	    return;
	}
	break;
    }

    CVMconsolePrintf("a method form of %d parameters\n", thisEntry->nParameters);

}

void
CVMtypeidPrintDiffs( CVMBool verbose ){
    const char *title;
    struct sigForm * form;
#ifdef NO_RECYCLE
    if ( verbose ){
	title = "Name and Type ID diffs: additions, deletions, both (verbose)";
    }else {
	title = "Name and Type ID diffs: additions & deletions";
    }
#else
    title = "Name and Type ID diffs: additions only";
#endif
    CVMconsolePrintf("============ %s ============\n", title);

    CVMconsolePrintf("\nMember Name Table:\n");
    findDiffsInSegmentedTable((genericTableSegment*)&CVMtypeidNameEntries,
                              sizeof(CVMTypeIDNameEntry),
                              memberDiffs, verbose);

    CVMconsolePrintf("\nField Type Table:\n");
    findDiffsInSegmentedTable((genericTableSegment *)&CVMtypeidClassEntries,
                              sizeof(CVMTypeIDClassEntry),
                              fieldDiffs, verbose);

    CVMconsolePrintf("\nMethod Type Table:\n");
    findDiffsInSegmentedTable((genericTableSegment *)&CVMtypeidMethodSigEntries,
                              sizeof(CVMTypeIDMethodSigEntry),
                              methodDiffs, verbose);
    CVMconsolePrintf("Method Form Table:\n");
    for ( form = *CVMformTablePtr; form != NULL; form = form->next ){
	if ( (form->state&~TYPEID_STATE_INROM) != 0 ){
	    formDiffs( form, verbose );
	    form->state = 0;
	}
    }
    CVMconsolePrintf("=========END %s DNE=========\n", title);

}

#endif


/**************************************************************
  Member names are kept in a table. They are indexed.
  NOTE: There are 3 primary databases for the typeid system.  These are:
     1. CVMtypeidNameEntries  - tracks field and method names
     2. CVMtypeidClassEntries - tracks class types (and therefore field types)
     3. CVMtypeidMethodSigEntries - tracks method signature types
*/

/* Purpose: Finds an empty slot in the member names database.  This function
   also ensures that we not exceed the CVM_TYPEID_MAX_MEMBERNAME limit for
   the member name typeids.
*/
static CVMTypeIDNameEntry *
findFreeNameEntry(CVMTypeIDToken *newIndex)
{
    CVMTypeIDNameEntry *retval;
    retval = (CVMTypeIDNameEntry *)
        findFreeTableEntry((genericTableSegment *)&CVMtypeidNameEntries,
                           sizeof(CVMTypeIDNameEntry),
                           &CVMglobals.typeidNameSegmentSize,
                           newIndex);

    if ((retval!=NULL) && (*newIndex > CVM_TYPEID_MAX_MEMBERNAME)) {
	/*
	 * No malloc failure, but
	 * table overflow. Give it back and return a null.
	 */
	genericTableSegment *thisSeg;
        (void)indexNameNoCheck(*newIndex, &thisSeg);
	thisSeg->numberOfFreeEntries += 1;
	retval->refCount = 0;
        unlockThrowInternalError(
            "Combined number of method and field names exceeds vm limit.");
	*newIndex = TYPEID_NOENTRY;
	return NULL;
    }
    return retval;
}

/*
 * Unlink an unused membername from the table and release
 * its resources. This is called from CVMtypeidDisposeMembername
 * when a name's reference count reaches zero, or from 
 * CVMtypeidNew*IDFromNameAndSig when there is an allocation or
 * lookup error after a membername is created but while it still
 * has zero reference count and is unneeded.
 */
static void
deleteNameEntry(CVMTypeIDNameEntry *thisEntry,
                CVMTypeIDToken nameToken,
                CVMTypeIDNameSegment *thisSeg)
{
    /*
     * First, take it off the hash chain.
     * and add to the segment's free count.
     */
    unsigned hashVal =
        computeHash(thisEntry->name, (int)strlen(thisEntry->name)) %
        CVM_TYPEID_NAME_HASH_SIZE;
    CVMTypeIDToken *pCell = &CVMtypeidNameHash[hashVal];
    ASSERT_LOCKED;
    CVMtraceTypeID(("Typeid: Deleting member name %s\n", thisEntry->name));
    unlinkEntry(nameToken, thisEntry->nextIndex, pCell, 
                (genericTableSegment*)&CVMtypeidNameEntries, 
                (genericTableSegment*)thisSeg, 
                sizeof(CVMTypeIDNameEntry));
#ifndef NO_RECYCLE
    /*
     * now delete the malloc'd memory.
     * Since the refCount is already zero, we're done.
     */
    free((char *)thisEntry->name); /* cast away const */
    thisEntry->name = NULL;
#endif
#ifdef CVM_DEBUG
    thisEntry->state |= TYPEID_STATE_DELETED;
    idstat.nNamesDeleted++;
#endif
}

static CVMTypeIDNameEntry *
referenceName(CVMExecEnv *ee,
              const char *name, 
              CVMTypeIDToken *nameToken,
              CVMBool doInsertion)
{
    unsigned hashVal = computeHash(name, (int)strlen(name)) %
                       CVM_TYPEID_NAME_HASH_SIZE;
    CVMTypeIDToken *hashbucket = &CVMtypeidNameHash[hashVal];
    CVMTypeIDToken thisIndex;
    CVMTypeIDNameEntry *thisName = NULL;

    /* The hash bucket is a link list of entry nodes.  Walk through the list in
       this bucket, and look for a node where the entry's name string matches
       the requested name: */
    for (thisIndex = *hashbucket;
         thisIndex != TYPEID_NOENTRY;
         thisIndex = thisName->nextIndex) {

	const char *namestring;
	thisName = indexName(thisIndex, NULL);
	namestring = thisName->name;
	/* Assert that we don't have a race with a client deleting the
	 * entry. This would be an indication of a client doing a lookup
	 * when it should be doing a new.
	 */
	CVMassert((thisName->refCount != 0) && (namestring != NULL));
	if (strcmp(namestring, name) == 0) {
	    /* found one */
	    if (doInsertion) {
		conditionalIncRef(thisName);
	    }
	    break;
	}
    }
    if (thisIndex == TYPEID_NOENTRY) {
	/* didn't find */
	/* if doInsertion, then add it in, else fail */
	thisName = NULL;
	if (doInsertion) {
            CVMTypeIDToken freeEntry;
	    char *newname;
	    size_t namelength = strlen(name);
	    ASSERT_LOCKED;
            thisName = findFreeNameEntry(&freeEntry);
	    newname = (char *)malloc(namelength + 1);
	    if ((thisName == NULL) || (newname == NULL)) {
		if (thisName != NULL) {
		    /*
		     * Just tell the segment it has one more free entry.
		     */
		    struct genericTableSegment *thisSeg;
		    (void)indexNameNoCheck( freeEntry, &thisSeg );
		    thisSeg->numberOfFreeEntries += 1;
		    thisName = NULL;
		    unlockThrowOutOfMemoryError(); /* malloc failed */
		} else {
		    if ( newname != NULL ){
			free( newname );
		    }
		    /* InternalError already thrown by findFreeNameEntry(). */
		}
		thisIndex = freeEntry = TYPEID_NOENTRY;
	    } else {
		thisIndex = freeEntry;
		strcpy(newname, name);
		newname[namelength] = '\0';
		thisName->name = newname;
		thisName->nextIndex = *hashbucket;
		thisName->refCount = 1;
		*hashbucket = freeEntry;
		CVMtraceTypeID(("Typeid: New member name %s\n", newname));
#ifdef CVM_DEBUG
		thisName->state = TYPEID_STATE_ADDED;
		idstat.nNamesAdded++;
#endif
	    }
	}
    }
    if (nameToken != NULL) {
        *nameToken = thisIndex;
    }
    return thisName;
}

#if 0 /* NOT used */

CVMNameTypeID
CVMtypeidLookupMemberName(CVMExecEnv *ee, const char *name)
{
    CVMTypeIDToken thisIndex = TYPEID_NOENTRY;
    CVMNameTypeID resultID;
    CVMTypeIDNameEntry *thisName;
    thisName = referenceName(ee, name, &thisIndex, CVM_FALSE);
    if (thisName == NULL) {
	return CVM_NAME_TYPEID_ERROR;
    }
    CVMtypeidSetToken(resultID, thisIndex);
    return resultID;
}

#endif /* NOT used */

CVMNameTypeID
CVMtypeidNewMemberName(CVMExecEnv *ee, const char *name)
{
    CVMNameTypeID nameID;
    CVMTypeIDToken nameToken;
    CVMTypeIDNameEntry * thisName;
    CVMsysMutexLock(ee, &CVMglobals.typeidLock);
    thisName = referenceName(ee, name, &nameToken, CVM_TRUE);
    if (thisName == NULL) {
	nameID = CVM_NAME_TYPEID_ERROR;
    } else {
        CVMtypeidSetToken(nameID, nameToken);
    }
    CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);
    return nameID;
}

#if 0 /* NOT used */
/* Purpose: Clones the member name typeID for another use.  Effectively, this
   just means to inc the reference count on that typeID to track its new usage.
*/
CVMNameTypeID
CVMtypeidCloneMemberName(CVMExecEnv *ee, CVMNameTypeID nameID)
{
    CVMTypeIDNameEntry *thisName;
    genericTableSegment *thisSeg;

    thisName = indexName(CVMtypeidGetToken(nameID), &thisSeg);

    CVMsysMutexLock(ee, &CVMglobals.typeidLock);
    conditionalIncRef(thisName);
    CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);

    return nameID;
}
#endif /* NOT used */


void
CVMtypeidDisposeMemberName(CVMExecEnv *ee, CVMNameTypeID nameID)
{
    CVMTypeIDNameEntry *thisName;
    genericTableSegment *thisSeg;
    CVMTypeIDToken nameToken = CVMtypeidGetToken(nameID);

    thisName = indexName(nameToken, &thisSeg);
    CVMassert(thisName != NULL);
    CVMsysMutexLock(ee, &CVMglobals.typeidLock);
    if (thisName->refCount != MAX_COUNT) {
	if (--(thisName->refCount) == 0) {
	    deleteNameEntry(thisName, nameToken,
                            (CVMTypeIDNameSegment*)thisSeg);
	}
    }
    CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);
}

/****************************************************************************
 * type structures are allocated in arrays, called segments,
 * which are linked together.
 * They are allocated, reference counted, freed, and re-used.
 * Here is the management code.
 */

/* Purpose: Finds an empty slot in the class type database.  This function
   also ensures that we do not exceed the CVM_TYPEID_MAX_BASETYPE limit
   of the class typeids.
*/
static CVMTypeIDClassEntry *
findFreeClassEntry(CVMTypeIDToken *newIndex)
{
    CVMTypeIDClassEntry *retval;
    retval = (CVMTypeIDClassEntry *)
        findFreeTableEntry((genericTableSegment *)&CVMtypeidClassEntries,
                           sizeof(CVMTypeIDClassEntry),
                           &CVMglobals.typeidClassSegmentSize,
                           newIndex);

    if ((retval!=NULL) && (*newIndex > CVM_TYPEID_MAX_BASETYPE)) {
	/*
	 * No malloc failure, but
	 * table overflow. Give it back and return a null.
	 */
	struct genericTableSegment *thisSeg;
        (void)indexClassNoCheck(*newIndex, &thisSeg);
	thisSeg->numberOfFreeEntries += 1;
	retval->refCount = 0;
	unlockThrowInternalError("Number of class names exceeds vm limit.");
	*newIndex = TYPEID_NOENTRY;
	return NULL;
    }
    return retval;
}

/*
 * Unlink an unused type entry from the table and release
 * its resources. This is called 
 * when an entry's reference count reaches zero, or 
 * when there is an allocation or
 * lookup error after one is created but while it still
 * has zero reference count and is unneeded.
 * This is for classes only. For big arrays, use
 * deleteArrayEntry.
 */
static void
deleteClassEntry(CVMTypeIDClassEntry *thisEntry,
                 CVMTypeIDToken classToken,
                 CVMTypeIDClassSegment* thisSeg)
{
    /*
     * First, take it off the hash chain.
     * and add to the segment's free count.
     */
    unsigned 	 hashVal;
    struct pkg * thisPkg;
    CVMTypeIDToken *pCell;

    ASSERT_LOCKED;
    CVMassert( thisEntry->tag == CVM_TYPE_ENTRY_OBJ );
    classToken &= CVMtypeidBaseTypeMask;
    thisPkg = thisEntry->value.className.package;
    hashVal = computeHash(thisEntry->value.className.classInPackage,
                  (int)strlen(thisEntry->value.className.classInPackage))
              % NCLASSHASH;
    CVMtraceTypeID(("Typeid: Deleting class (%d ) %s/%s\n",
                    classToken, thisPkg->pkgname,
                    thisEntry->value.className.classInPackage));
    pCell = &thisPkg->typeData[hashVal];
    unlinkEntry(classToken, thisEntry->nextIndex, pCell,
                (genericTableSegment *)&CVMtypeidClassEntries,
                (genericTableSegment *)thisSeg,
                sizeof(CVMTypeIDClassEntry) );
#ifndef NO_RECYCLE
    /*
     * now delete the malloc'd memory and 
     * note in segment header.
     * The refCount is already zero.
     */
    free( (char*)(thisEntry->value.className.classInPackage) ); /* cast away const */
    thisEntry->value.className.classInPackage = NULL;
    thisEntry->tag = CVM_TYPE_ENTRY_FREE;
#endif
#ifdef CVM_DEBUG
    thisEntry->state |= TYPEID_STATE_DELETED;
    idstat.nClassesDeleted++;
#endif
    /* reference count the package, too */
    if ( thisPkg->refCount != MAX_COUNT ){
	if ( --(thisPkg->refCount) == 0 ){
	    deletePackage( thisPkg );
	}
    }
}

static void
deleteArrayEntry(CVMTypeIDClassEntry *thisEntry,
                 CVMTypeIDToken arrayToken,
                 CVMTypeIDClassSegment *thisSeg)
{
    CVMTypeIDClassEntry *baseEntry;
    unsigned 	 hashVal;
    struct pkg * thisPkg;

    ASSERT_LOCKED;
    CVMassert( thisEntry->tag == CVM_TYPE_ENTRY_ARRAY );
    /*
     * First, take it off the hash chain.
     * and add to the segment's free count.
     * We are in the hash chain of the package of the base type
     * or the null package.
     */
    if (CVMtypeidTokenIsRef(thisEntry->value.bigArray.basetype)) {
	baseEntry = indexClass(thisEntry->value.bigArray.basetype, NULL);
	thisPkg = baseEntry->value.className.package;
	hashVal = computeHash(baseEntry->value.className.classInPackage,
                      (int)strlen(baseEntry->value.className.classInPackage))
                  % NCLASSHASH;
    } else {
	baseEntry = NULL;
	thisPkg = CVMnullPackage;
	hashVal = 0;
    }
    arrayToken &= CVMtypeidBaseTypeMask;
    CVMtraceTypeID(("Typeid: Deleting array (%d ) %s/%s[%d]\n",
		    arrayToken, thisPkg->pkgname,
		    (baseEntry==NULL)?"<none>":baseEntry->value.className.classInPackage,
		    thisEntry->value.bigArray.depth ));
    unlinkEntry(arrayToken, thisEntry->nextIndex,
                &thisPkg->typeData[hashVal],
                (genericTableSegment *)&CVMtypeidClassEntries,
                (genericTableSegment *)thisSeg,
                sizeof(CVMTypeIDClassEntry));
#ifndef NO_RECYCLE
    thisEntry->tag = CVM_TYPE_ENTRY_FREE;
#endif
    /*
     * All this entry contains is a reference to its baseclass.
     * DecRef that thing, if it is indeed a class.
     */
    if ( (baseEntry!=NULL) && (baseEntry->refCount != MAX_COUNT) ){
	if ( --(baseEntry->refCount) == 0 ){
	    deleteClassEntry( baseEntry, thisEntry->value.bigArray.basetype, NULL );
	}
    }
#ifdef CVM_DEBUG
    thisEntry->state |= TYPEID_STATE_DELETED;
    idstat.nArraysDeleted++;
#endif
    /* reference count the package, too */
    if ( thisPkg->refCount != MAX_COUNT ){
	if ( --(thisPkg->refCount) == 0 ){
	    deletePackage( thisPkg );
	}
    }
}

static void
deleteClassTypeEntry(CVMTypeIDClassEntry *thisEntry,
                     CVMTypeIDToken classToken,
                     CVMTypeIDClassSegment *thisSeg)
{
    if (thisEntry->tag == CVM_TYPE_ENTRY_ARRAY) {
	deleteArrayEntry(thisEntry, classToken, thisSeg);
    } else {
	deleteClassEntry(thisEntry, classToken, thisSeg);
    }
}

static void
decrefClassTypeEntry(CVMTypeIDToken typeCookie)
{
    CVMTypeIDClassEntry *thisType;
    struct genericTableSegment*	typeSeg;

    ASSERT_LOCKED;
    typeCookie &= CVMtypeidBaseTypeMask; /* note BASE TYPE ONLY */
    if (isTableEntry(typeCookie)) {
	thisType = indexClass(typeCookie, &typeSeg);
	if (thisType->refCount != MAX_COUNT) {
	    if (--(thisType->refCount) == 0) {
		deleteClassTypeEntry(thisType, typeCookie,
                                     (CVMTypeIDClassSegment *)typeSeg);
	    }
	}
    }
}

/*******************************************************************
 * The basis of type-structure lookup is the package.
 * This introduces another layer of data-structure management.
 * Here it is.
 */

extern struct pkg * const CVMnullPackage;

static struct pkg *
lookupPkg(const char * pkgname, int namelength, CVMBool doInsertion){
    unsigned nameHash;
    struct pkg ** hashbucket;
    struct pkg *  pkgp;
    char	  firstchar;
    if ( namelength == 0 ) return CVMnullPackage;

    nameHash = computeHash( pkgname, namelength );
    hashbucket = &CVM_pkgHashtable[ nameHash%NPACKAGEHASH ];
    firstchar = pkgname[0];
    for ( pkgp = *hashbucket; pkgp != NULL; pkgp = pkgp->next ){
	/*
	 * compare this one with that one.
	 * Integer comparison is cheap, for an opener.
	 */
	const char * namestring = pkgp->pkgname;
	/* Assert that we don't have a race with a client deleting the
	 * entry. This would be an indication of a client doing a lookup
	 * when it should be doing a new.
	 */
	CVMassert((pkgp->refCount != 0) && (namestring != NULL));
	if ( namestring[0] != firstchar)
	    continue;
	if ( strncmp( namestring, pkgname, namelength ) != 0 )
	    continue;
	if (namestring[namelength] == '\0' )
	    break; /* we have a winner */
    }
    /*
     * Either off the end of the list, or found a winner
     */
    if ( doInsertion && (pkgp == NULL) ){
	/*
	 * Not there. Already locked.
	 * Add it.
	 * First allocate all the space in one single allocation
	 */
	char * newname;
	ASSERT_LOCKED;
	pkgp = (struct pkg *)calloc( 1, sizeof( struct pkg ) + namelength+1 );
	if ( pkgp == NULL ){
	    /* malloc failure */
	    unlockThrowOutOfMemoryError();
	} else {
	    int i;

	    /* now compute where we really want things within the allocation */
	    newname = (char *)( pkgp+1 ); /* C idiom in use here */

	    pkgp->pkgname = strncpy( newname, pkgname, namelength );
	    newname[namelength] = '\0';
	    pkgp->next    = *hashbucket;
	    /*
	     * Nothing in this hash table yet
	     */
	    for (i = 0; i < NCLASSHASH; i++) {
		pkgp->typeData[i] = TYPEID_NOENTRY;
	    }
	    *hashbucket = pkgp;
	    pkgp->refCount = 0; /* no references yet */
	    CVMtraceTypeID(("Typeid: New package %s\n", newname));
#ifdef CVM_DEBUG
	    pkgp->state = TYPEID_STATE_ADDED;
	    idstat.nPkgAdded++;
#else
	    pkgp->state = 0;
#endif
	}
    }
    return pkgp;
}

static void
deletePackage( struct pkg *pkgp ){
    struct pkg ** hashbucket;
    unsigned nameHash;
#ifdef CVM_DEBUG
    int i;
#endif
    
    CVMassert( pkgp->refCount == 0 );
    CVMtraceTypeID(("Typeid: Deleting package %s\n", pkgp->pkgname));
#ifdef CVM_DEBUG
    /* ensure hash table is empty */
    for ( i = 0 ; i < NCLASSHASH; i++ ){
	CVMassert( pkgp->typeData[i] == TYPEID_NOENTRY );
    }
    idstat.nPkgDeleted++;
#endif
    nameHash = computeHash( pkgp->pkgname, (int)strlen(pkgp->pkgname) );
    hashbucket = &CVM_pkgHashtable[ nameHash%NPACKAGEHASH ];
    while ( *hashbucket != pkgp ){
	CVMassert( *hashbucket != NULL ); /* seems redundant */
	hashbucket = &((*hashbucket)->next);
    }
    *hashbucket = pkgp->next; /* unlink from hash chain. */
    /*
     * Since the package and its name are allocated by a single calloc
     * call, this will free both at once.
     */
    free( pkgp );
}


/********************************************************
 * Many of the user operations on these are quite straightforward.
 * Here are a number of them.
 * The only hard part is parsing and lookup of signatures or type names.
 * That is saved until last.
 */

#ifdef CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT

/* Purpose: Gets the array depth from the class typeid. */
int
CVMtypeidGetArrayDepthX(CVMClassTypeID classID)
{
    CVMTypeIDClassEntry *ep;
    CVMTypeIDToken t = CVMtypeidGetToken(classID);
    if (!isTableEntry(t)) {
	/* got here in error. deal with it. */
	return t >> CVMtypeidArrayShift;
    }
    ep = indexClass(t & CVMtypeidBaseTypeMask, NULL);
    if (ep->tag == CVM_TYPE_ENTRY_ARRAY) {
	return (int)ep->value.bigArray.depth;
    }
    /* non-array has a depth of 0 */
    return 0;

}

/* Purpose: Gets the base element type from the class typeid. */
CVMClassTypeID
CVMtypeidGetArrayBaseTypeX(CVMClassTypeID classID)
{
    CVMTypeIDClassEntry *ep;
    CVMTypeIDToken t = CVMtypeidGetToken(classID);
    if (!isTableEntry(t)) {
	/* got here in error. deal with it. */
        CVMClassTypeID result;
        CVMtypeidSetToken(result, t & CVMtypeidBaseTypeMask);
        return result;
    }
    ep = indexClass(t & CVMtypeidBaseTypeMask, NULL);
    if (ep->tag == CVM_TYPE_ENTRY_ARRAY) {
        CVMClassTypeID result;
	CVMtypeidSetToken(result, ep->value.bigArray.basetype);
        return result;
    }
    /* non-array has a bad basetype of 0? */
    return CVM_CLASS_TYPEID_ERROR;
}

#endif /* CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT */

/***************************************************************
 *
 * Lookup a class, having already found its package.
 * Insert if appropriate. Return a pointer to the classname
 * or null if not found and we're not inserting.
 * also, set *classCookie to the index of the entry, classCookie!=0
 */
static CVMTypeIDClassEntry *
lookupClass(const char     *classname,
            int             namelength,
            struct pkg     *pkgp,
            CVMBool         doInsertion,
            CVMTypeIDToken *classCookie)
{
    unsigned nameHash = computeHash(classname, namelength);
    CVMTypeIDToken *hashbucket = &pkgp->typeData[nameHash % NCLASSHASH];
    CVMTypeIDClassEntry         *classp = NULL;
    CVMTypeIDToken              classIndex;
    char			firstchar = classname[0];
    char			lChar;
    const char *		thisname;
    int				l = namelength;
    int				lm1;

    if (l > 255 ){
	l = 255;
    }
    lm1 = l - 1;
    lChar = classname[lm1];

    /* DEBUG printf( "looking for class %s in package %s\n",
	classname, pkgp->pkgname ); */
    for (classIndex = *hashbucket;
         classIndex != TYPEID_NOENTRY;
         classIndex = classp->nextIndex) {

        classp = indexClass(classIndex, NULL);
	if ( classp->tag != CVM_TYPE_ENTRY_OBJ)
	    continue;
	thisname = classp->value.className.classInPackage;
	/* Assert that we don't have a race with a client deleting the
	 * entry. This would be an indication of a client doing a lookup
	 * when it should be doing a new.
	 */
	CVMassert((classp->refCount != 0) && (thisname != NULL));
	/* DEBUG printf("... compare to %s\n",thisname); */
	if (classp->nameLength != l)
	    continue;
	if ((thisname[0] != firstchar) || (thisname[lm1] != lChar))
	    continue;
	if (strncmp(classname, thisname, namelength) != 0)
	    continue;
	if (thisname[namelength] == '\0') {
	    /* DEBUG printf("... found it!\n"); */
	    if ( doInsertion ){
		conditionalIncRef(classp);
	    }
	    break;
	}
    }
    /*
     * Either found an entry, or didn't
     */
    if (classIndex == TYPEID_NOENTRY) {
	classp = NULL;
	if (doInsertion) {
	    /*
	     * it really is absent and we want to 
	     * insert it.
	     */
	    char * newname;
	    ASSERT_LOCKED;
	    /* DEBUG printf("... inserting class %s\n", classname ); */
	    classp = findFreeClassEntry(&classIndex);
	    newname = (char *)malloc( namelength+1);
	    if ( (classp==NULL) || (newname==NULL ) ){
		/* malloc failure */
		if ( classp!= NULL){
		    /*
		     * Give back the table entry. Actually, just tell the
		     * segment it has one more free entry.
		     */
		    struct genericTableSegment * thisSeg;
		    (void)indexClassNoCheck( classIndex, &thisSeg );
		    thisSeg->numberOfFreeEntries += 1;
		    classp = NULL;
                    /* must have been a malloc() failure */
		    unlockThrowOutOfMemoryError();
		} else {
		    if ( newname != NULL ){
			free( newname );
		    }
		    /* InternalError already thrown by findFreeClassEntry */
		}
		classIndex = CVM_TYPEID_ERROR;
	    } else {
		classp->tag = CVM_TYPE_ENTRY_OBJ;
		strncpy( newname, classname, namelength );
		newname[namelength] = '\0';
		classp->value.className.classInPackage = newname;

		classp->nextIndex = *hashbucket;
		classp->value.className.package = pkgp;
		classp->refCount = 1;
		classp->nameLength = l;
		*hashbucket       = classIndex;
		conditionalIncRef( pkgp );
		CVMtraceTypeID(("Typeid: New class (%d ) %s/%s\n",
				classIndex, pkgp->pkgname, newname));
#ifdef CVM_DEBUG
		classp->state = TYPEID_STATE_ADDED;
		idstat.nClassesAdded++;
#endif
	    }
	}
    }
    /* now have an entry    */
    if (classCookie != NULL) {
        *classCookie = classIndex;
    }

    if (classIndex == TYPEID_NOENTRY) {
	return NULL;
    }

    return classp;
}


static CVMTypeIDClassEntry *
referenceClass(const char *classname,
               int namelength,
               CVMBool doInsertion,
               CVMTypeIDToken *classCookie)
{
    /*
     * Parse into class part and package part.
     * Package part may be null!
     */
    const char*		pkgEnd;
    const char*		classInPkg;
    int 		pkgLength;
    int			classInPkgLength;
    struct pkg *	pkgp;
    CVMTypeIDClassEntry *classp;


    /* The following is equivalent to ... 
     * pkgEnd = (char*)memrchr(classname, '/', namelength);
     */
    for (pkgEnd = classname + namelength - 1; *pkgEnd != '/'; pkgEnd --){
	if (pkgEnd == classname){
	    pkgEnd = NULL;
	    break;
	}
    }
    /*
     * if the test clause of the "for" was false, then *pkgEnd == '/'
     * otherwise pkgEnd == NULL
     */
    CVMassert((pkgEnd == NULL) || (*pkgEnd == '/'));

    if (pkgEnd == NULL ){
	/* no separation, so the class name starts right at the beginning */
	pkgLength = 0;
	classInPkg = classname;
	classInPkgLength = namelength;
    } else {
	/* found a separating / */
	pkgLength =  pkgEnd - classname;
	classInPkg = pkgEnd + 1;
	classInPkgLength = namelength - pkgLength - 1;
    }
    pkgp = lookupPkg(classname, pkgLength, doInsertion);
    if ( pkgp == NULL ) return NULL;
    classp = lookupClass(classInPkg, classInPkgLength,
			 pkgp, doInsertion, classCookie);
    if (classp == NULL){
	/*
	 * See if this was to have been the first class
	 * in its package. If so, we should free the package.
	 */
	if (pkgp->refCount == 0){
	    deletePackage(pkgp);
	}
    }
    return classp;
}

#ifdef CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT
/*
 * Lookup an array, having already found its package.
 * Insert if appropriate. Return a pointer to the entry
 * or null if not found and we're not inserting.
 * also, set *classCookie to the index of the entry, classCookie!=0
 */

static CVMTypeIDClassEntry *
lookupArray(CVMTypeIDToken basetype,
            CVMTypeIDClassEntry *baseEntry,
            int depth,
            struct pkg *pkgp,
            CVMBool doInsertion,
            CVMTypeIDToken *classCookie)
{
    unsigned int basenameHash =
        (baseEntry==NULL) ? 0
            : computeHash(baseEntry->value.className.classInPackage,
		  (int)strlen(baseEntry->value.className.classInPackage));
    CVMTypeIDToken *hashbucket = &pkgp->typeData[basenameHash % NCLASSHASH];
    CVMTypeIDToken  arrayIndex;
    CVMTypeIDClassEntry *arrayp = NULL;

    /* DEBUG printf( "looking for array[%d of %x in package %s\n",
	depth, basetype, pkgp->pkgname ); */

    for (arrayIndex = *hashbucket;
         arrayIndex != TYPEID_NOENTRY;
         arrayIndex = arrayp->nextIndex) {

        arrayp = indexClass(arrayIndex, NULL);
	if ( arrayp->tag != CVM_TYPE_ENTRY_ARRAY)
	    continue;
	if ((arrayp->value.bigArray.basetype == basetype) &&
            (arrayp->value.bigArray.depth == depth)) {
	    /*DEBUG printf("... found it!\n"); */
	    if (doInsertion) {
		conditionalIncRef(arrayp);
	    }
	    break;
	}
    }
    /*
     * Either found an entry, or didn't
     */
    if (arrayIndex == TYPEID_NOENTRY) {
	arrayp = NULL;
	arrayIndex = CVM_TYPEID_ERROR; /* probably redundant */
	if (doInsertion) {
	    /*
	     * Not there, will add entry.
	     */
	    ASSERT_LOCKED;
	    /*DEBUG printf("... inserting class %s\n", classname ); */
	    arrayp = findFreeClassEntry(&arrayIndex);
	    if (arrayp != NULL) {
		arrayp->tag = CVM_TYPE_ENTRY_ARRAY;
		arrayp->refCount = 1;
		if (baseEntry != NULL) {
		    conditionalIncRef(baseEntry);
		}
		arrayp->value.bigArray.basetype = basetype;
		arrayp->value.bigArray.depth    = depth;
		arrayp->nextIndex    = *hashbucket;
		*hashbucket = arrayIndex;
		conditionalIncRef(pkgp);
                CVMtraceTypeID(("Typeid: New array (%d ) %s/%s[%d]\n",
                    arrayIndex, pkgp->pkgname,
                    (baseEntry==NULL)? "<none>"
                        : baseEntry->value.className.classInPackage, depth));
#ifdef CVM_DEBUG
		arrayp->state = TYPEID_STATE_ADDED;
		idstat.nArraysAdded++;
#endif
	    }
	}
    }
    if (classCookie != NULL) {
        *classCookie = arrayIndex;
    }
    return arrayp;
}
#endif /* CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT */


CVMBool
CVMtypeidIsSameClassPackage(CVMClassTypeID classname1,
                            CVMClassTypeID classname2)
{
    CVMTypeIDToken comparand[2];
    struct pkg * 	pkg[2];
    int 		i;

    comparand[0] = CVMtypeidGetToken(classname1);
    comparand[1] = CVMtypeidGetToken(classname2);

    /* find base type cookie for each */
    /* this strips off any layers of arrays */
    for (i = 0; i < 2; i++) {
	if (CVMtypeidTokenIsBigArray(comparand[i])) {
	    CVMTypeIDClassEntry *arrayp;
	    arrayp =
                indexClass(comparand[i] & CVMtypeidBaseTypeMask, NULL);
	    comparand[i]  = arrayp->value.bigArray.basetype;
	} else {
	    comparand[i] &= CVMtypeidBaseTypeMask;
	}
    }
    /* find base type class entries for each ( if any ),
     * and the packages, too
     */
    for (i = 0; i < 2; i++) {
	if (CVMtypeidTokenIsPrimitive(comparand[i])) {
	    pkg[i] = CVMnullPackage;
	} else {
	    CVMTypeIDClassEntry *baseclass;
	    baseclass = indexClass(comparand[i] , NULL);
	    pkg[i] = baseclass->value.className.package;
	}
    }

    /* now that we have a package pointer, comparison is trivial */
    return pkg[0] == pkg[1];
}


/* Purpose: Creates a class table entry for the specified signature string
   if not already created.  Functionally, it behaves like referenceClass(),
   except that this function parses field signatures instead of straight
   forward classnames like referenceClass() does.

   Hence, it is really creating the token for a CVMClassTypeID, not a
   CVMFieldTypeID.  Don't get confused by the name!!!
*/
static CVMTypeIDClassEntry *
referenceFieldSignature(CVMExecEnv *ee, const char *sig, int sigLength,
                        CVMBool doInsertion, CVMTypeIDToken *retToken)
{
    CVMTypeIDToken typeToken = CVM_TYPEID_ERROR;
    CVMTypeIDClassEntry *thisEntry = NULL;
    int depth=0;
    CVMTypeIDToken basetype = CVM_TYPEID_ERROR;
    CVMTypeIDClassEntry *baseEntry = NULL;
    struct pkg *basePackage = CVMnullPackage;
    const char *name = sig;

    while (*sig == CVM_SIGNATURE_ARRAY && sigLength > 0) {
	depth += 1;
	sig += 1;
	sigLength -= 1;
    }
    CVMassert(depth <= CVM_MAX_ARRAY_DIMENSIONS);

    if (sigLength <= 0) {
	goto returnSig;
    }

    switch (*sig) {
    case CVM_SIGNATURE_VOID:
	/* technically illegal as a type, but we'll let it pass. */
	basetype = CVM_TYPEID_VOID;
	break;
    case CVM_SIGNATURE_INT:
	basetype = CVM_TYPEID_INT;
	break;
    case CVM_SIGNATURE_SHORT:
	basetype = CVM_TYPEID_SHORT;
	break;
    case CVM_SIGNATURE_CHAR:
	basetype = CVM_TYPEID_CHAR;
	break;
    case CVM_SIGNATURE_LONG:
	basetype = CVM_TYPEID_LONG;
	break;
    case CVM_SIGNATURE_BYTE:
	basetype = CVM_TYPEID_BYTE;
	break;
    case CVM_SIGNATURE_FLOAT:
	basetype = CVM_TYPEID_FLOAT;
	break;
    case CVM_SIGNATURE_DOUBLE:
	basetype = CVM_TYPEID_DOUBLE;
	break;
    case CVM_SIGNATURE_BOOLEAN:
	basetype = CVM_TYPEID_BOOLEAN;
	break;
    case CVM_SIGNATURE_CLASS:
	sig += 1; /* skip the L */
	sigLength -= 2; /* discount the ; */
	baseEntry = referenceClass(sig, sigLength, doInsertion, &basetype);

	if (baseEntry == NULL) {
	    goto returnSig; /* error! */
	}
	basePackage = baseEntry->value.className.package;
	break;
    default:
	goto returnSig; /* error! */
    }
#ifdef CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT
    if (depth <= CVMtypeidMaxSmallArray) 
#endif
    {
	thisEntry = baseEntry;
        CVMassert((basetype & CVMtypeidBaseTypeMask) == basetype);
	typeToken = (((CVMTypeIDToken)depth)<<CVMtypeidArrayShift) | basetype;
	/* goto returnSig; */
#ifdef CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT
    } else {
	/*
	 * else its a big array
	 * lookupArray will reference count the underlying baseclass.
	 * but and the entry itself!
	 * At this point, the baseclass count may be TOO BIG, since
	 * referenceClass (called above) also incremented it.
	 * Adjust downward. I promise it will never go below 1.
	 */
	thisEntry = lookupArray(basetype, baseEntry, depth, basePackage,
                                doInsertion, &typeToken);
	if (thisEntry != NULL) {
	    typeToken = CVMtypeidBigArray | typeToken;
	    if (doInsertion && (baseEntry != NULL) &&
                (baseEntry->refCount != MAX_COUNT)) {
		CVMtraceTypeID(("Typeid: field signature base entry adjustment"
                                " to class %s\n",
                                baseEntry->value.className.classInPackage));
		baseEntry->refCount -= 1;
		CVMassert(baseEntry->refCount != 0);
	    }
	}
#endif /* CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT */
    }

returnSig:
    if (thisEntry != NULL) {
	CVMassert(thisEntry->refCount != 0);
    }
    if (retToken != NULL) {
	*retToken = typeToken;
    }
    if (typeToken == CVM_TYPEID_ERROR && doInsertion &&
        !CVMexceptionOccurred(ee)) {
        unlockThrowNoClassDefFoundError(name);
    }
    return thisEntry;
}

/* Purpose: Creates a new classID for arrays of the specified base type
   and depth increment.  Note: the base type may itself be an array type.
   Just like CVMtypeidNewClassID(), this function will increment the
   refCount on the classID.
*/
CVMClassTypeID
CVMtypeidIncrementArrayDepth(CVMExecEnv *ee,
                             CVMClassTypeID base,
                             int depthIncrement)
{
    CVMClassTypeID arrayID;
    CVMTypeIDToken baseToken;
#ifdef CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT
    CVMTypeIDToken arrayToken;
    CVMTypeIDClassEntry *baseEntry;
    CVMTypeIDClassEntry *arrayEntry;
    struct pkg *basePackage;
#endif /* CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT */
    CVMUint32 newDepth = CVMtypeidGetArrayDepth(base) + depthIncrement;

    base = CVMtypeidGetArrayBaseType(base);
    baseToken = CVMtypeidGetToken(base);

#ifdef CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT
    if (newDepth <= CVMtypeidMaxSmallArray) 
#endif /* CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT */
    {
	if (isTableEntry(baseToken)) {
	    base = CVMtypeidCloneClassID(ee, base);
	}
        CVMtypeidSetToken(arrayID,
                          ((newDepth << CVMtypeidArrayShift) | baseToken));
        return arrayID;
    }

#ifdef CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT
    if (CVMtypeidTokenIsRef(baseToken)) {
	baseEntry = indexClass(baseToken, NULL);
	basePackage = baseEntry->value.className.package;
    } else {
	baseEntry   = NULL;
	basePackage = CVMnullPackage;
    }

    /*
     * look up the big array in the type table. We set
     * parameter doInsertion to TRUE for the case that an array of this
     * depth, of this base type has never been seen before.
     */
    CVMsysMutexLock(ee, &CVMglobals.typeidLock);
    arrayEntry = lookupArray(baseToken, baseEntry, newDepth, basePackage,
                             CVM_TRUE, &arrayToken);
    if (arrayEntry == NULL) {
	arrayToken = CVM_TYPEID_ERROR;
    } else {
        arrayToken |= CVMtypeidBigArray;
    }
    CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);

    CVMtypeidSetToken(arrayID, arrayToken);

    return arrayID;
#endif /* CVM_TYPEID_NEED_BIG_ARRAY_SUPPORT */
}

/* Purpose: Looks up an existing classID for the specified class signature. */
CVMClassTypeID
CVMtypeidLookupClassID(CVMExecEnv *ee,
                       const char *name,
                       int nameLength)
{
    CVMTypeIDToken token = CVM_TYPEID_ERROR;
    CVMClassTypeID classID;
    CVMTypeIDClassEntry *ep;
    if (name[0] == CVM_SIGNATURE_ARRAY) {
	/* it starts with a [ so it is really an array */
	ep = referenceFieldSignature(ee, name, nameLength, CVM_FALSE, &token);
    } else {
	/* It is a simple name */
	ep = referenceClass(name, nameLength, CVM_FALSE, &token);
	if (ep == NULL) {
	    token = CVM_TYPEID_ERROR;
	}
    }
    CVMtypeidSetToken(classID, token);
    return classID;
}

/* Purpose: Creates a new classID for the specified class signature. */
CVMClassTypeID
CVMtypeidNewClassID(CVMExecEnv *ee,
                    const char *name,
                    int nameLength)
{
    CVMTypeIDToken token = CVM_TYPEID_ERROR;
    CVMClassTypeID classID;
    CVMTypeIDClassEntry *ep;

    /* Detect an empty string */ 
    CVMassert(name[0] != '\0');

    CVMsysMutexLock(ee, &CVMglobals.typeidLock);
    if (name[0] == CVM_SIGNATURE_ARRAY) {
	/* it starts with a [ so it is really an array */
	ep = referenceFieldSignature(ee, name, nameLength, CVM_TRUE, &token);
    } else {
	/* It is a simple name */
	ep = referenceClass(name, nameLength, CVM_TRUE, &token);
	if (ep == NULL) {
	    token = CVM_TYPEID_ERROR;
	}
    }
    CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);
    CVMtypeidSetToken(classID, token);
    return classID;
}

/* Purpose: Clones the classID for another use.  Effectively, this just means
   to inc the reference count on that typeID to track its new usage.
*/
CVMClassTypeID
CVMtypeidCloneClassID(CVMExecEnv *ee, CVMClassTypeID classID)
{
    CVMTypeIDToken token = CVMtypeidGetToken(classID);
    CVMTypeIDClassEntry *thisType;

    if (isTableEntry(token)) {
	CVMsysMutexLock(ee, &CVMglobals.typeidLock);
	thisType = indexClass(token, NULL);
        CVMassert(thisType != NULL);
	conditionalIncRef(thisType);
	CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);
    }

    return classID;
}

/* Purpose: Disposes of the specified classID.  Effectively, this just means
   to decrement the reference count on that typeID to indicate that it has one
   less user.  If the ount i 0 after the decrement, the classID will be freed.
*/
void
CVMtypeidDisposeClassID(CVMExecEnv *ee, CVMClassTypeID classID)
{
    CVMTypeIDToken token = CVMtypeidGetToken(classID);

    if (isTableEntry(token)) {
	CVMsysMutexLock(ee, &CVMglobals.typeidLock);
	decrefClassTypeEntry(token);
	CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);
    }

}

/**********************************************************************/

/*
 * Sufficiently large forms are worth sharing.
 * Fortunately, there aren't many of them, so the lookup is primitive.
 */
static struct sigForm *
formLookup(CVMExecEnv *ee, CVMUint32 * datap, int nSyllables,
           CVMBool doInsertion)
{
    struct sigForm * thisForm;
    int i;
    int nwords = FORM_DATAWORDS(nSyllables);
    int nParameters = nSyllables-2;

    for (thisForm = *CVMformTablePtr;
         thisForm != NULL;
         thisForm = thisForm->next) {

	if (thisForm->nParameters != nParameters)
	    continue;
	for ( i = 0; i < nwords; i++ ){
	    if ( datap[i] != thisForm->data[i] )
		goto notEqual;
	}
	/* seems to be the one */
	if ( doInsertion ){
	    conditionalIncRef( thisForm );
	}
	return thisForm;
    notEqual:; /* continue looking */
    }
    /* not found */
    if ( (thisForm==NULL) && doInsertion){
	ASSERT_LOCKED;
	thisForm = (struct sigForm *)malloc(sizeof(struct sigForm) +
                                            (nwords-1) * (sizeof(CVMUint32)));
	if ( thisForm == NULL ){
	    unlockThrowOutOfMemoryError();
	} else {
	    thisForm->nParameters = nParameters;
	    for ( i = 0; i < nwords; i++ ){
		thisForm->data[i] = datap[i];
	    }
	    thisForm->refCount = 1;
	    thisForm->next = *CVMformTablePtr;
	    *CVMformTablePtr = thisForm;
#ifdef CVM_DEBUG
	    thisForm->state = TYPEID_STATE_ADDED;
	    idstat.nMethodFormsAdded++;
#endif
	}
    }
    return thisForm;
}

/* Purpose: Finds an empty slot in the method signatures database.  This
   function also ensures that the we do not exceed the CVM_TYPEID_MAX_SIG
   limit for the method ignature typeids.
*/
static CVMTypeIDMethodSigEntry *
findFreeMethodSigEntry(CVMTypeIDToken *newIndex)
{
    CVMTypeIDMethodSigEntry *retval;
    retval = (CVMTypeIDMethodSigEntry *)
        findFreeTableEntry((genericTableSegment *)&CVMtypeidMethodSigEntries,
                           sizeof(CVMTypeIDMethodSigEntry),
                           &CVMglobals.typeidMethodSigSegmentSize,
                           newIndex);

    if ((retval!=NULL) && (*newIndex > CVM_TYPEID_MAX_SIG)) {
	/*
	 * no malloc failure, but
	 * table overflow. Give it back and return a null.
	 */
	genericTableSegment *thisSeg;
        (void)indexMethodSigNoCheck(*newIndex, &thisSeg);
	thisSeg->numberOfFreeEntries += 1;
	retval->refCount = 0;
        unlockThrowInternalError(
            "Number of method signatures exceeds vm limit.");
	*newIndex = TYPEID_NOENTRY;
	return NULL;
    }
    return retval;
}

/*
 * Evaluation of CVMTypeIDMethodSigEntry records:
 * The following function is needed to discover how many OBJ
 * things we have in a terse form, which determines where the
 * details array is (directly in details.data, or indirectly in
 * details.datap).
 * Parameters are:
 *	mp:	pointer to the CVMTypeIDMethodSigEntry of interest
 *	formp:  pointer to variable receiving the form-data pointer
 *	detailp: pointer to variable receiving the detail-pointer
 * Return value: 
 *	number of OBJ in the sig, including return value.
 */
static int
getSignatureInfo(CVMTypeIDMethodSigEntry *mp,
                 CVMUint32** formp,
                 CVMTypeIDToken** detailp)
{
    int	      nSyl = mp->nParameters+2;
    int	      nWords = FORM_DATAWORDS(nSyl);
    int       wordNo;
    CVMUint32 dataword;
    unsigned  syl;
    int       nObj = 0;
    CVMUint32 *formdata;

    formdata = (nSyl <= FORM_SYLLABLESPERDATUM) ?
                   &mp->form.formdata : mp->form.formp->data;

    for (wordNo = 0; wordNo < nWords; wordNo++) {
	dataword = formdata[wordNo];
	while ((syl = dataword&0xf) != 0) {
	    dataword >>= 4;
	    if (syl==CVM_TYPEID_OBJ) {
		nObj += 1;
            }
	}
    }
    if (formp!= NULL) {
	*formp = formdata;
    }
    if (detailp != NULL) {
        /* TODO: Currently, the detailp allow only room for 1 CVMTypeIDToken
           detail.  This is because that's how much room is available in the
           space that is needed for details.datap.  Investigate if there is
           some way to store more compressed details in this space instead
           of using a straight CVMTypeIDToken.
        */
	*detailp = (nObj <= NUMBER_OF_METHOD_INLINE_DETAILS) ?
	               mp->details.data : mp->details.datap;
    }
    return nObj;
}

/*
 * There are 4 subspecies of signatures:
 * 1) inline form, inline details
 * 2) inline form, out-of-line details,
 * 3) out-of-line form, inline details
 * 4) out-of-line form, out-of-line details.
 */
#define INLINE_FORM	0
#define OUTLINE_FORM	1
#define INLINE_DETAILS	0
#define OUTLINE_DETAILS	2

#ifdef CVM_TRACE
static const char * const signatureMatrix[] = {
    "inline form/inline detail",
    "outline form/inline detail",
    "inline form/outline detail",
    "outline form/outline detail"
};
#endif

static void
decrefForm( struct sigForm * formp ){
    if ( formp->refCount != MAX_COUNT ){
	if ( --(formp->refCount) == 0 ){
	    /*
	     * remove from linked list,
	     * then free the space.
	     */
	    struct sigForm ** formpp = CVMformTablePtr;
	    CVMassert( *formpp != NULL );
	    while ( *formpp != formp ){
		formpp = &((*formpp)->next);
		CVMassert( *formpp != NULL );
	    }
	    *formpp = formp->next;
#ifndef NO_RECYCLE
	    free( formp );
#else
#ifdef CVM_DEBUG
	    formp->state |= TYPEID_STATE_DELETED;
#endif
#endif
#ifdef CVM_DEBUG
	    idstat.nMethodFormsDeleted++;
#endif
	}
    }
}

static void
deleteMethodSignatureEntry(CVMTypeIDMethodSigEntry *thisEntry,
                           CVMTypeIDToken sigToken,
                           CVMTypeIDMethodSigSegment *thisSeg)
{
    int		nSyl;
    int		nDetail;
    int		sigSpecies;
    struct sigForm *formp;
    CVMUint32 *formdata;
    CVMTypeIDToken *detailp;
    int		i;

    unsigned 	hashVal;
    /*
     * First, ascertain which species of signature we have here.
     * This determines how much work we have to do.
     */
    nDetail = getSignatureInfo(thisEntry, &formdata, &detailp);

    if ((nSyl = thisEntry->nParameters+2) <= FORM_SYLLABLESPERDATUM) {
	sigSpecies = INLINE_FORM;
	formp = NULL;
    } else {
	sigSpecies = OUTLINE_FORM;
	formp = thisEntry->form.formp;
    }

    if (nDetail <= NUMBER_OF_METHOD_INLINE_DETAILS) {
	sigSpecies |=  INLINE_DETAILS;
    } else {
	sigSpecies |=  OUTLINE_DETAILS;
    }
    CVMtraceTypeID(("Typeid: Deleting %s method signature at 0x%x\n",
	signatureMatrix[ sigSpecies ], thisEntry));

    /*
     * Now, take it off the hash chain.
     * and add to the segment's free count.
     */

    hashVal = (formdata[0] << 16) + (nDetail>0 ? detailp[0] : 0);
    hashVal %= NMETHODTYPEHASH;

    ASSERT_LOCKED;
    unlinkEntry(sigToken, thisEntry->nextIndex,
                &CVMtypeidMethodSigHash[hashVal], 
                (genericTableSegment*)&CVMtypeidMethodSigEntries,
                (genericTableSegment*)thisSeg,
                sizeof(CVMTypeIDMethodSigEntry));
    /*
     * decRef the detail fields
     * COPIED from CVMtypeidDisposeFieldID
     * CONSIDER SUBROUTINIZING
     */
    for (i = 0; i < nDetail; i++) {
	decrefClassTypeEntry(detailp[i]);
    }
    /*
     * The details array is not shared. Delete if external
     */
    if (sigSpecies&OUTLINE_DETAILS) {
#ifndef NO_RECYCLE
	free(detailp);
#endif
#ifdef CVM_DEBUG
	idstat.nMethodDetailsDeleted++;
#endif
    }
    /*
     * The form structure, if external, is ref-counted.
     */
    if (sigSpecies&OUTLINE_FORM) {
	decrefForm(formp);
    }

#ifdef CVM_DEBUG
    thisEntry->state |= TYPEID_STATE_DELETED;
    idstat.nMethodSigsDeleted++;
#endif
}

/* constants used by CVMtypeidMethodSignatureToType */
#define MAX_SIGITEMS	257
#define NLOCALDETAIL 6
#define NLOCALSYLLABLEWORDS 2
#define NLOCALSYLLABLES (NLOCALSYLLABLEWORDS*FORM_SYLLABLESPERDATUM)


static CVMTypeIDMethodSigEntry * 
lookupMethodSignature(CVMExecEnv *ee,
                      int sigSpecies, /* combination of the above flags */
                      int nformwords,
                      int nSyllables,
                      int nDetail,
                      CVMTypeIDToken *hashbucket,
                      CVMUint32 *syllablep,
                      CVMTypeIDToken *detailp,
                      CVMTypeIDToken *methodCookie,
                      CVMBool *foundExistingEntry,
                      CVMBool doInsertion)
{
    CVMTypeIDMethodSigEntry *thisSig;
    CVMTypeIDToken	thisSigNo;
    int			nParameters = nSyllables-2;

    /* DEBUG
	int i;
	CVMconsolePrintf("lookupMethodSignature: species %x, %d syllables,"
                         " %d details\n", sigSpecies, nSyllables, nDetail);
	CVMconsolePrintf("	syllables:");
	for ( i = 0; i < nformwords; i++ ){
	    CVMconsolePrintf(" 0x%x", syllablep[0] );
	}
	if ( nDetail != 0 ){
	    CVMconsolePrintf("\n    details:");
	    for ( i = 0; i < nDetail; i++ ){
		if ( detailp[i] >= TYPEID_NOENTRY ){
		    CVMconsolePrintf(" ERROR" );
		} else {
		    CVMconsolePrintf(" %s",
			CVMtypeidFieldTypeToAllocatedCString(detailp[i]));
		}
	    }
	}
	CVMconsolePrintf("\n");

    */
    for (thisSigNo = *hashbucket;
         thisSigNo != TYPEID_NOENTRY;
         thisSigNo = thisSig->nextIndex) {

	CVMTypeIDToken *thisData;
	int	     detailword;
	thisSig = indexMethodSig(thisSigNo, NULL);
	/*
	 * compare size of forms
	 */
	if (thisSig->nParameters != nParameters) {
	    continue;
        }
	/*
	 * compare forms
	 */
	if (sigSpecies&OUTLINE_FORM){
	    CVMUint32 * thisForm = thisSig->form.formp->data;
	    int formword;
	    for (formword = 0; formword < nformwords; formword++) {
		if (syllablep[formword] != thisForm[formword])
		    goto continueSigLoop;
	    }
	} else {
	    if (syllablep[0] != thisSig->form.formdata)
		goto continueSigLoop;
	}
	/*
	 * compare details.
	 * (if the forms are identical, so the number of details will be, too)
	 */
	thisData = (sigSpecies & OUTLINE_DETAILS) ?
                       thisSig->details.datap : thisSig->details.data;
	for (detailword = 0; detailword < nDetail; detailword ++) {
	    if (detailp[detailword] != thisData[detailword]) {
		goto continueSigLoop;
            }
	}
	/*
	 * Everything compares equal. we have a winner
	 */
	*foundExistingEntry = CVM_TRUE;
	goto returnThisEntry;

    continueSigLoop:;
    }
    /*
     * Fell out of compare loop. Must make a new one and add it.
     * Or not.
     */
    thisSig = NULL;
    *foundExistingEntry = CVM_FALSE;

    if (doInsertion) {
	/*
	 * is absent. Do all allocations first,
	 * then fill in all data.
	 */
	struct sigForm* externalForm  = NULL;
	CVMTypeIDToken *externalDetail = NULL;
	ASSERT_LOCKED;
	thisSig = findFreeMethodSigEntry(&thisSigNo);
	if (thisSig == NULL) goto mallocFailure;
	if (sigSpecies&OUTLINE_FORM) {
	    externalForm = formLookup(ee, syllablep, nSyllables, CVM_TRUE);
	    if (externalForm == NULL) goto mallocFailure;
	}
	if (sigSpecies&OUTLINE_DETAILS) {
	    externalDetail = (CVMTypeIDToken *)
		malloc(nDetail * sizeof(CVMTypeIDToken));
	    if (externalDetail == NULL) {
		unlockThrowOutOfMemoryError();
		goto mallocFailure;
	    }
#ifdef CVM_DEBUG
	    idstat.nMethodDetailsAdded++;
#endif
	}
	/*
	 * all allocations done. finish building the data structures
	 * and linking this entry into the hash chain.
	 */
	thisSig->nParameters = nParameters;
	if (sigSpecies & OUTLINE_FORM) {
	    thisSig->form.formp = externalForm;
	} else {
	    thisSig->form.formdata = syllablep[0];
	}
	if (sigSpecies & OUTLINE_DETAILS) {
	    thisSig->details.datap = externalDetail;
	    memcpy(externalDetail, detailp, nDetail * sizeof(CVMTypeIDToken));
	} else {
	    memcpy(thisSig->details.data, detailp,
                   nDetail * sizeof(CVMTypeIDToken));
	}
	thisSig->nextIndex = *hashbucket;
	thisSig->refCount = 0;
	*hashbucket = thisSigNo;
	CVMtraceTypeID(("Typeid: Creating %s method signature at 0x%x\n",
	    signatureMatrix[ sigSpecies ], thisSig));
#ifdef CVM_DEBUG
	idstat.nMethodSigsAdded++;
	thisSig->state |= TYPEID_STATE_ADDED;
#endif
	if (CVM_FALSE) {
    mallocFailure:
	    /*
	     * This is where we end up only in the case
	     * of an allocation failure while trying to
	     * instantiate a new method type. Either the
	     * method sig table was full, or I could not
	     * allocate a new form, or I could not allocate
	     * a new external details list.
	     * See what is allocated, if anything, and 
	     * free it or un-ref-count it.
	     */
	    if (thisSig!= NULL) {
		/* don't call deleteMethodSignatureEntry because
		 * it expects a fully-formed entry which is in the hash table.
		 * we don't have this. We just have a table entry to give back.
		 */
		struct genericTableSegment * thisSeg;
		(void)indexMethodSigNoCheck(thisSigNo, &thisSeg);
		thisSeg->numberOfFreeEntries += 1;
		thisSig = NULL;
	    }
	    if (externalForm != NULL){
		decrefForm(externalForm);
	    }
	    if (externalDetail != NULL) {
		free(externalDetail);
	    }
	    thisSigNo = CVM_TYPEID_ERROR;
	}
    }

returnThisEntry:

    if (thisSig != NULL && doInsertion) {
	conditionalIncRef(thisSig);
    }
    if (methodCookie != NULL) {
	*methodCookie = thisSigNo;
    }
    return thisSig;
}

/*
 * Buffers used in referenceMethodSignature when the signatures get
 * too big to parse using the stack buffers. Make sure to acquire the
 * typeidLock before using them! This will hardly ever happen.
 * The macro is used in two places.
 */
static CVMTypeIDToken staticDetailBuffer[MAX_SIGITEMS];
static CVMUint32      staticSyllableBuffer[FORM_DATAWORDS(MAX_SIGITEMS)];

#define USE_STATIC_BUFFERS \
    if (!doInsertion) {                                           \
        needToUnlock = CVM_TRUE;                                  \
        CVMsysMutexLock(ee, &CVMglobals.typeidLock);              \
    }                                                             \
    detailp = staticDetailBuffer;                                 \
    memcpy(detailp, localDetailBuffer,                            \
           NLOCALDETAIL * sizeof(localDetailBuffer[0]));          \
                                                                  \
    syllablep = staticSyllableBuffer;                             \
    memcpy(syllablep, localSyllableBuffer,                        \
           NLOCALSYLLABLEWORDS * sizeof(localSyllableBuffer[0])); \
    memset(&syllablep[NLOCALSYLLABLEWORDS], 0,                    \
           sizeof(CVMUint32) *                                    \
           (FORM_DATAWORDS(MAX_SIGITEMS)-NLOCALSYLLABLEWORDS));

static CVMTypeIDMethodSigEntry *
referenceMethodSignature(CVMExecEnv *ee,
                         const char *sig,
                         int sigLength,
                         CVMTypeIDToken *sigToken,
                         CVMBool doInsertion)
{
    CVMTypeIDToken localDetailBuffer[NLOCALDETAIL];
    CVMUint32	localSyllableBuffer[NLOCALSYLLABLEWORDS];
    const char*	subtypeStart;
    const char*	endSig;
    CVMTypeIDToken *detailp;
    CVMUint32*	syllablep;
    int		nDetail = 0;
    int		nSyllables = 1; /* reserve one for return type! */
    CVMTypeIDToken thisSyllable;
    CVMTypeIDToken thisDetail;
    int		isReturnValue = 0;
    int		foundReturnValue = 0;
    int		sigFlavor, nformword;
    int		copyCtr;
    CVMTypeIDMethodSigEntry *thisSig = NULL;
    CVMBool	foundExistingEntry;
    CVMTypeIDToken thisSigNo = TYPEID_NOENTRY;
    CVMUint32	hashBucket;
    CVMBool	needToUnlock = CVM_FALSE; /* set by USE_STATIC_BUFFERS */

    detailp = localDetailBuffer;
    syllablep = localSyllableBuffer;
    endSig = sig + sigLength;

    memset(localSyllableBuffer, 0,
           NLOCALSYLLABLEWORDS * sizeof(localSyllableBuffer[0]));
    if (sig[0] != CVM_SIGNATURE_FUNC) {
	if (sigToken != NULL) {
	    *sigToken = TYPEID_NOENTRY;
        }
	return NULL;
    }
    sig += 1;
    sigLength -= 1;
    while (sig < endSig) {
	if (foundReturnValue) {
	    /* CVMconsolePrintf("referenceMethodSignature failing: "
                                "excess post-return value\n"); */
	    goto parseFailure;
	}
	switch (*sig) {
	case CVM_SIGNATURE_VOID:
	    if (!isReturnValue) {
		/* CVMconsolePrintf("referenceMethodSignature failing:"
                                    " void parameter\n"); */
		goto parseFailure; /* no void parameters! */
	    }
	    thisSyllable = CVM_TYPEID_VOID;
	    break;
	case CVM_SIGNATURE_INT:
	    thisSyllable = CVM_TYPEID_INT;
	    break;
	case CVM_SIGNATURE_SHORT:
	    thisSyllable = CVM_TYPEID_SHORT;
	    break;
	case CVM_SIGNATURE_CHAR:
	    thisSyllable = CVM_TYPEID_CHAR;
	    break;
	case CVM_SIGNATURE_LONG:
	    thisSyllable = CVM_TYPEID_LONG;
	    break;
	case CVM_SIGNATURE_BYTE:
	    thisSyllable = CVM_TYPEID_BYTE;
	    break;
	case CVM_SIGNATURE_FLOAT:
	    thisSyllable = CVM_TYPEID_FLOAT;
	    break;
	case CVM_SIGNATURE_DOUBLE:
	    thisSyllable = CVM_TYPEID_DOUBLE;
	    break;
	case CVM_SIGNATURE_BOOLEAN:
	    thisSyllable = CVM_TYPEID_BOOLEAN;
	    break;
	case CVM_SIGNATURE_ARRAY:
	    subtypeStart = sig++;
	    while (sig < endSig && *sig == CVM_SIGNATURE_ARRAY) {
		sig += 1;
	    }
	    if (sig >= endSig) {
		/* bummer */
		/* CVMconsolePrintf("referenceMethodSignature failing:"
                                    " mal-formed array type\n"); */
		goto parseFailure; /* no void parameters! */
	    }
            if(*sig == CVM_SIGNATURE_CLASS) {
		sig += 1;
		goto doClasstype;
	    }
	    goto doObjecttype;

	case CVM_SIGNATURE_CLASS:
	    subtypeStart = sig++;

	doClasstype:
            while (sig < endSig && *sig != CVM_SIGNATURE_ENDCLASS) {
		sig += 1;
	    }
	    if ( sig >= endSig ){
		/* bummer */
		/* CVMconsolePrintf("referenceMethodSignature failing:"
                                    " mal-formed class type\n"); */
		goto parseFailure; /* no void parameters! */
	    }

	doObjecttype:
	    /*
	     * Now, subtypeStart points at the initial [ or L
	     * and sig points at the last character of this parameter.
	     */
            referenceFieldSignature(ee, subtypeStart,
                                    (int)(sig-subtypeStart+1), doInsertion,
                                    &thisDetail);
	    /*
	     * if isReturnValue, then detail gets inserted at the beginning of
             * the detail array (yeucch), otherwise it gets appended at end.
	     * Combine this with the possibility of overflowing our local
             * buffer and needing to use the static one, and we have 4 choices.
	     * We will deal with this in a simple but ineffecient manner.
	     */
            if (nDetail == NLOCALDETAIL && detailp == localDetailBuffer) {
		/* local buffers inadequate, use static buffers */
		USE_STATIC_BUFFERS
	    }
	    if (isReturnValue) {
		for (copyCtr = nDetail; copyCtr > 0; copyCtr--) {
		    detailp[copyCtr] = detailp[copyCtr-1];
		}
		nDetail++;
		detailp[0] = thisDetail;
	    } else {
		detailp[nDetail++] = thisDetail;
	    }
	    thisSyllable = CVM_TYPEID_OBJ;
	    break;

	case CVM_SIGNATURE_ENDFUNC:
	    /* if (isReturnValue) already, this is an error */
	    if (isReturnValue) {
		/* CVMconsolePrintf("referenceMethodSignature failing:"
                                    " duplicate )\n"); */
		goto parseFailure; /* no void parameters! */
	    }
	    thisSyllable = CVM_TYPEID_ENDFUNC;
	    break;

	default:
	    goto parseFailure; /* unrecognized syllable */
	}
	sig += 1;

	if (isReturnValue) {
	    syllablep[0] |= thisSyllable;
	    foundReturnValue = 1;
	} else {
	    if ((nSyllables == NLOCALSYLLABLES) &&
                (syllablep==localSyllableBuffer)) {
		/*
		 * About to overflow local buffer. 
		 */
		USE_STATIC_BUFFERS
	    } else if (nSyllables >= MAX_SIGITEMS) {
		/*
		 * MAX_SIGITEMS = 257:
		 *	255 parameters (acutally less in many cases)
		 *	1   ENDFUNC
		 *	1   return value.
		 * Here we have too many:
		 *     syllable 0 is the return value
		 *     syllable 1 is the 1st parameter
		 *     ...
		 *     syllable n is the ENDFUNC marker
		 *         for n >0 && n <= 256
		 */
		/* CVMconsolePrintf("referenceMethodSignature failing:"
                                    " too many parameters\n"); */
		goto parseFailure;
	    }
            syllablep[nSyllables / FORM_SYLLABLESPERDATUM] |=
                thisSyllable << (4 * (nSyllables % FORM_SYLLABLESPERDATUM));
	    nSyllables += 1;
            if (thisSyllable == CVM_TYPEID_ENDFUNC) {
		/* the next type is the return type */
		isReturnValue = 1;
	    }
	}
    }
    if (!foundReturnValue) {
        /* CVMconsolePrintf("referenceMethodSignature failing:"
                            " no return value\n"); */
        goto parseFailure;
    }
    /*
     * if (nSyllables > 20) {
     *	   CVMconsolePrintf("Whopper signature has %d syllables\n", nSyllables);
     * }
     */

    sigFlavor  = (nSyllables <= FORM_SYLLABLESPERDATUM) ?
                     INLINE_FORM : OUTLINE_FORM;
    sigFlavor |= (nDetail <= NUMBER_OF_METHOD_INLINE_DETAILS) ?
                     INLINE_DETAILS : OUTLINE_DETAILS;
    nformword = FORM_DATAWORDS(nSyllables);

    /* compute hash value. index into hash table */
    hashBucket = (syllablep[0] << 16) + (nDetail > 0 ? detailp[0] : 0);
    hashBucket %= NMETHODTYPEHASH;

    thisSig = lookupMethodSignature(ee, sigFlavor, nformword,
                                    nSyllables, nDetail,
                                    &CVMtypeidMethodSigHash[hashBucket],
                                    syllablep, detailp, &thisSigNo,
                                    &foundExistingEntry, doInsertion);
    /*DEBUG
	if ( thisSig == NULL ){
	    CVMconsolePrintf("referenceMethodSignature failing:"
                             " lookup failed\n");
	}
    */

    if (foundExistingEntry && doInsertion) {
	/*
	 * when looking up the details, we bumped their ref counts
	 * needlessly. Undo that.
	 */
	int i;
	CVMtraceTypeID(("Typeid: Component adjustment for method"
                        " signature at 0x%x\n", thisSig));

        for(i = 0; i < nDetail; i++) {
            decrefClassTypeEntry(detailp[i]);
	}
    }
    if (needToUnlock) {
        CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);
    }
    if (sigToken != NULL) {
	*sigToken = thisSigNo;
    }
    return thisSig;

parseFailure:
    /* Any input parse errors come here, to 
     * clean up before returning.
     */
    if (doInsertion) {
	/*
	 * when looking up the details, we bumped their ref counts
	 * needlessly. Undo that.
	 */
	int i;
        for(i = 0; i < nDetail; i++) {
            decrefClassTypeEntry(detailp[i]);
	}
    }
    if (needToUnlock) {
        CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);
    }
    if (sigToken != NULL) {
	*sigToken = TYPEID_NOENTRY;
    }

    return NULL;
}


/* Purpose: Finds an empty slot in the name and type database. */
static CVMTypeIDNameAndTypeEntry *
findFreeNameAndTypeEntry(CVMTypeIDToken *freeID)
{
    CVMTypeIDNameAndTypeEntry *entry;
    entry = (CVMTypeIDNameAndTypeEntry *)
        findFreeTableEntry((genericTableSegment *)&CVMtypeidNameAndTypeEntries,
                           sizeof(CVMTypeIDNameAndTypeEntry),
                           &CVMglobals.typeidNameAndTypeSegmentSize,
                           freeID);

    /* NOTE: Unlike for nameEntries, we don't need to have a limit on the
       number of nameAndTypeEntries.  The nameEntry index needs to be encoded
       into a bit field (hence, its limitation).  The nameAndTypeEntry has
       no such requirement, and therefore no limit.

       Hence, we do not check against some index limit and relinquish the
       entry here as findFreeNameEntry() does.
    */

    /* Return the found entry.  If not available, entry will be NULL. */
    return entry;
}

static CVMMemberTypeID
referenceNameAndType(CVMExecEnv *ee,
                     CVMTypeIDToken nameToken,
                     CVMTypeIDToken typeToken,
                     CVMBool doInsertion)
{
    CVMTypeIDNameAndTypeEntry *entry = NULL;
    CVMMemberTypeID memberID = CVM_MEMBER_TYPEID_ERROR;

    unsigned hashVal = (nameToken ^ typeToken) %
                       CVM_TYPEID_NAME_AND_TYPE_HASH_SIZE;
    CVMTypeIDToken *hashBucket = &CVMtypeidNameAndTypeHash[hashVal];
    CVMTypeIDToken thisIndex;

    CVMTypeIDToken baseToken;
    CVMTypeIDToken depthToken;

    baseToken = typeToken & CVMtypeidBaseTypeMask;
    depthToken = typeToken >> CVMtypeidArrayShift;

    /* Encode a small memberID if possible: */
    /* The encoding for small memberIDs is as follows:

                name   arrayDepth   baseType   marker
         bits    16         2           13        1

       marker is the bit that, if set, indicates that the memberID is of the
       small encoding (above) as opposed to the CVMMemberTypeID pointer format
       below.

       baseType maps to the lower 13 bits of the sigID component of the
       memberID.

       arrayDepth maps to bit 24 and 25 of the sigID component of the memberID.

       name maps to the lower 16 bits of the nameID component of the memberID.
    */
    if (((nameToken & 0xffff) == nameToken) &&
        ((depthToken & 0x3) == depthToken) &&
        ((baseToken & 0x1fff) == baseToken)) {

        CVMTypeIDToken result = ((nameToken  << 16) |
                                 (depthToken << 14) |
                                 (baseToken  << 1)  | 0x1);

        return (CVMMemberTypeID)result;
    }


    /* The hash bucket is a link list of entry nodes.  Walk through the list in
       this bucket, and look for a node where the entry's name and type tokens
       matches the requested name and type: */
    thisIndex = *hashBucket;
    for (thisIndex = *hashBucket;
         thisIndex != TYPEID_NOENTRY;
         thisIndex = entry->nextIndex) {

        entry = indexNameAndType(thisIndex, NULL);
	if (CVMtypeidGetToken(entry->compID.nameX) == nameToken &&
            CVMtypeidGetToken(entry->compID.typeX) == typeToken) {
            /* We found a matching entry! */
            if (doInsertion) {
                /* Inc the ref count on the entry if appropriate: */
                conditionalIncRef(entry);
            }
            break;
        }
    }

    /* If we didn't find an existing entry that matches the specified name and
       type, the create a new entry if needed.  Else, use the existing entry
       to determine the memberID:
    */
    if (thisIndex == TYPEID_NOENTRY) {
	/* If we get here, then we weren't able to find an entry for the
           specified name and type.  If doInsertion (i.e. a request to add
           an entry) is TRUE, then add a new entry, else fail:
        */
        entry = NULL;
        if (doInsertion) {
            CVMTypeIDToken freeID;
            ASSERT_LOCKED;
            entry = findFreeNameAndTypeEntry(&freeID);
            if (entry != NULL) {
                CVMtypeidSetToken(entry->compID.nameX, nameToken);
                CVMtypeidSetToken(entry->compID.typeX, typeToken);

                entry->refCount = 1;

                /* Add this entry to the bucket link list: */
		entry->nextIndex = *hashBucket;
                *hashBucket = freeID;
		CVMtraceTypeID(("Typeid: New name and type 0x%x 0x%x\n",
                                nameToken, typeToken));
#ifdef CVM_DEBUG
		entry->state = TYPEID_STATE_ADDED;
		idstat.nNamesAdded++;
#endif
                /* Encode big memberID form based on a new entry: */
                memberID = (CVMMemberTypeID)&entry->compID;
            }
        }
    } else {
        /* Encode big memberID form based on an existing entry: */
        memberID = (CVMMemberTypeID)&entry->compID;
    }

    return memberID;
}


/*
 * Convert type ID to string for printouts
 */
CVMBool
CVMtypeidMethodTypeToCString(CVMMethodTypeID t, char* buf, int bufLength)
{
    char *chp;
    CVMSigIterator sigIterator;
    CVMTypeIDToken i;
    CVMBool	success = CVM_TRUE;

    chp = buf;

    CVMtypeidGetSignatureIterator(t, &sigIterator);

    conditionalPutchar(&chp, &bufLength, '(', &success);
    while ((i = CVM_SIGNATURE_ITER_NEXT(sigIterator)) != CVM_TYPEID_ENDFUNC) {
	switch (i) {

	BASETYPE_CASES

	default: {
		int thisLength;
		CVMtypeidTokenToCString(i, chp, bufLength, CVM_TRUE);
		chp += (thisLength = (int)strlen(chp));
		bufLength -=thisLength;
		break;
	    }
	}
    }
    conditionalPutchar(&chp, &bufLength, ')', &success);
    if (!success) return CVM_FALSE; /* bail early if we've alread overrun */
    /* Return type */
    switch (i = CVM_SIGNATURE_ITER_RETURNTYPE(sigIterator)) {

    BASETYPE_CASES

    default: {
	    int thisLength;
	    success = CVMtypeidTokenToCString(i, chp, bufLength, CVM_TRUE);
	    chp += (thisLength = (int)strlen(chp));
	    bufLength -=  thisLength;
	    break;
	}
    }
    *chp++ = '\0'; /* there's always room for nil */
    return success;
}

char *
CVMtypeidMethodTypeToAllocatedCString( CVMMethodTypeID t ){
    int length = (int)CVMtypeidMethodTypeLength(t) + 1;
    char * buf = (char *)malloc( length );
    if ( buf == NULL )
	return NULL; /* malloc failure */
    CVMtypeidMethodTypeToCString(t, buf, length );
    return buf;
}

/* Purpose: Fills in the specified buf[] with the string representation of
   the specified fieldID type. */
static CVMBool
CVMtypeidPrivateFieldTypeToCString(CVMTypeIDToken token, char* buf,
                                   int bufLength, CVMBool isField)
{
    char *chp;
    CVMAddr depth;
    CVMBool success = CVM_TRUE;

    chp = buf;
    if (CVMtypeidTokenIsBigArray(token)) {
        CVMTypeIDClassEntry *arrayp;
        arrayp = indexClass(token &CVMtypeidBaseTypeMask, NULL);
        depth = arrayp->value.bigArray.depth;
        token = arrayp->value.bigArray.basetype;
    } else {
        depth = token >> CVMtypeidArrayShift;
        token &= CVMtypeidBaseTypeMask;
    }
    while (depth-->0) {
	conditionalPutchar(&chp, &bufLength, '[', &success);
	isField = CVM_TRUE;
    }
    switch(token) {
#ifdef CVM_16BIT_TYPEID
    case TYPEID_NOENTRY:
#endif
    case CVM_TYPEID_ERROR:
        conditionalPutstring(&chp, &bufLength, "ERROR", sizeof("ERROR")-1,
                             &success);
        break;

    BASETYPE_CASES

    default: {
	CVMTypeIDClassEntry *basep = indexClass(token, NULL);
	if (isField) {
	    conditionalPutchar(&chp, &bufLength, 'L', &success);
        }
	if ((basep->value.className.package != NULL) &&
            (basep->value.className.package->pkgname != NULL) &&
            (basep->value.className.package->pkgname[0] != 0)) {
	    conditionalPutstring(&chp, &bufLength,
                basep->value.className.package->pkgname,
                (int)strlen(basep->value.className.package->pkgname),
                &success);
	    conditionalPutchar(&chp, &bufLength, '/', &success);
	}
	conditionalPutstring(&chp, &bufLength,
                             basep->value.className.classInPackage, 
                             (int)strlen(basep->value.className.classInPackage),
                             &success);
	if (isField) {
	    conditionalPutchar( &chp, &bufLength, ';', &success);
	}
    }
    }
    *chp = '\0';
    return success;
}

/* Purpose: Fills in the specified buf[] with the string representation of
   the specified fieldID type. */
CVMBool
CVMtypeidFieldTypeToCString(CVMFieldTypeID fID, char* buf, int bufLength)
{
    CVMClassTypeID classID = CVMtypeidGetMemberType(fID);
    CVMTypeIDToken token = CVMtypeidGetToken(classID);
    return CVMtypeidTokenToCString(token, buf, bufLength, CVM_TRUE);
}

/* Purpose: Allocates a buffer and fills it with the string representation of
   the specified fieldID type. */
char *
CVMtypeidFieldTypeToAllocatedCString(CVMFieldTypeID fID)
{
    int   bufLength = (int)CVMtypeidFieldTypeLength(fID) +1;
    char *buf = (char *)malloc(bufLength);
    if (buf == NULL) {
	return NULL; /* malloc failure */
    }

    {
        CVMClassTypeID classID = CVMtypeidGetMemberType(fID);
        CVMTypeIDToken token = CVMtypeidGetToken(classID);
        CVMtypeidTokenToCString(token, buf, bufLength, CVM_TRUE);
    }
    return buf;
}

/* Purpose: Fills in the specified buf[] with the string representation of
   the specified classID. */
CVMBool
CVMtypeidClassNameToCString(CVMClassTypeID classID, char* buf, int bufLength)
{
    CVMTypeIDToken token = CVMtypeidGetToken(classID);
    return CVMtypeidTokenToCString(token, buf, bufLength, CVM_FALSE);
}

CVMBool
CVMtypeidMethodNameToCString(CVMMethodTypeID methodID, char *buf, int bufLength)
{
    CVMNameTypeID nameID = CVMtypeidGetMemberName(methodID);
    CVMTypeIDNameEntry *mn = indexName(CVMtypeidGetToken(nameID), NULL);
    CVMBool success = CVM_TRUE;
    conditionalPutstring(&buf, &bufLength, mn->name, (int)strlen(mn->name),
                         &success);
    return success;
}

CVMBool
CVMtypeidFieldNameToCString(CVMFieldTypeID fieldID, char*buf, int bufLength)
{
    CVMNameTypeID nameID = CVMtypeidGetMemberName(fieldID);
    CVMTypeIDNameEntry *mn = indexName(CVMtypeidGetToken(nameID), NULL);
    CVMBool success = CVM_TRUE;
    conditionalPutstring(&buf, &bufLength, mn->name, (int)strlen(mn->name),
                         &success);
    return success;
}

char *
CVMtypeidMethodNameToAllocatedCString(CVMMethodTypeID methodID)
{
    CVMNameTypeID nameID = CVMtypeidGetMemberName(methodID);
    CVMTypeIDNameEntry *mn = indexName(CVMtypeidGetToken(nameID), NULL);
    char *result = (char *)malloc(strlen(mn->name) + 1);
    if (result == NULL) {
	return NULL; /* malloc failure */
    }
    strcpy(result, mn->name);
    return result;
}

char *
CVMtypeidFieldNameToAllocatedCString(CVMFieldTypeID fieldID)
{
    /* NOTE: fieldIDs and methodIDs are both instances of CVMCompositeTypeID,
       and their name field is implemented the same way.  That's why the
       following is safe and would work: */
    return CVMtypeidMethodNameToAllocatedCString((CVMMethodTypeID)fieldID);
}

/* Purpose: Allocates a buffer and fills it with the string representation of
   the specified classID. */
char *
CVMtypeidClassNameToAllocatedCString(CVMClassTypeID classID)
{
    int   bufLength = (int)CVMtypeidClassNameLength(classID) +1;
    char *buf = (char *)malloc(bufLength);
    if (buf == NULL) {
	return NULL; /* malloc failure */
    }

    {
        CVMTypeIDToken token = CVMtypeidGetToken(classID);
        CVMtypeidTokenToCString(token, buf, bufLength, CVM_FALSE);
    }
    return buf;
}

size_t
CVMtypeidFieldTypeLengthX(CVMTypeIDToken classToken, CVMBool isField)
{
    CVMAddr depth;
    size_t length = 0;
    if (CVMtypeidTokenIsBigArray(classToken)) {
        CVMTypeIDClassEntry *arrayp;
        arrayp = indexClass(classToken & CVMtypeidBaseTypeMask, NULL);
        depth = arrayp->value.bigArray.depth;
        classToken = arrayp->value.bigArray.basetype;
    } else {
        depth = classToken >> CVMtypeidArrayShift;
        classToken &= CVMtypeidBaseTypeMask;
    }
    if (depth > 0) {
	length += depth;
	isField = CVM_TRUE;
    }

    if (CVMtypeidTokenIsRef(classToken)) {
	CVMTypeIDClassEntry *basep = indexClass(classToken, NULL);
	if ((basep->value.className.package != NULL) &&
            (basep->value.className.package->pkgname != NULL) &&
            (basep->value.className.package->pkgname[0] != 0)) {
            /* Include the trailing slash: */
	    length +=  strlen(basep->value.className.package->pkgname) + 1;
	}
	length += strlen(basep->value.className.classInPackage);
	if (isField) {
	    length += 2; /* for the leading L and trailing ; */
        }
	return length;
    } else {
        /* one char for base name, and some number for the leading ['s */
        return length+1;
    }
}

size_t
CVMtypeidMemberNameLength(CVMNameTypeID memberID)
{
    CVMTypeIDToken token =  CVMtypeidGetToken(memberID);
    CVMTypeIDNameEntry *mn = indexName(token, NULL);
    return strlen(mn->name);
}

size_t
CVMtypeidMethodTypeLength(CVMMethodTypeID methodID)
{
    size_t length;
    CVMSigIterator sigIterator;
    int token;

    CVMtypeidGetSignatureIterator(methodID, &sigIterator);

    length = 2; /* one for ( and one for ) */
    while ((token = CVM_SIGNATURE_ITER_NEXT(sigIterator)) !=
           CVM_TYPEID_ENDFUNC) {
	if (CVMtypeidTokenIsRef(token)) {
	    length += CVMtypeidFieldTypeLengthX(token, CVM_TRUE);
	} else {
	    length += 1;
	}
    }

    /* Return type */
    token = CVM_SIGNATURE_ITER_RETURNTYPE(sigIterator);
    if (CVMtypeidTokenIsRef(token)) {
        length += CVMtypeidFieldTypeLengthX(token, CVM_TRUE);
    } else {
	length += 1;
    }
    return length;
}


/*****************************************************************
 *
 * The public entry point for manipulating the name/type
 * pairs, both for methods and for data.
 */

/*
 * Make a type ID out of a method name and a signature
 * No locking, no reference counting, no assurance that it will
 * exist by the time it is returned to you.
 */
CVMMethodTypeID
CVMtypeidLookupMethodIDFromNameAndSig(CVMExecEnv *ee,
                                      const CVMUtf8 *memberName,
                                      const CVMUtf8 *memberSig)
{
    CVMTypeIDNameEntry *nameEntry;
    CVMTypeIDMethodSigEntry *sigEntry;
    CVMTypeIDToken nameToken;
    CVMTypeIDToken sigToken;
    CVMMethodTypeID methodID;

    nameEntry = referenceName(ee, memberName, &nameToken, CVM_FALSE);
    if (nameEntry == NULL) {
	/* no such name */
	return CVM_METHOD_TYPEID_ERROR;
    }

    sigEntry = referenceMethodSignature(ee, memberSig, (int)strlen(memberSig),
                                        &sigToken, CVM_FALSE);
    if (sigEntry == NULL) {
	/* there was a parse or malloc failure. somewhere. */
        return CVM_METHOD_TYPEID_ERROR;
    }
    methodID = referenceNameAndType(ee, nameToken, sigToken, CVM_FALSE);

    return methodID;
}

CVMMethodTypeID
CVMtypeidNewMethodIDFromNameAndSig(CVMExecEnv *ee,
                                   const CVMUtf8 *memberName,
                                   const CVMUtf8* memberSig)
{
    CVMTypeIDNameEntry *name;
    CVMTypeIDMethodSigEntry *sig;
    CVMTypeIDToken nameToken;
    CVMTypeIDToken sigToken;
    CVMMethodTypeID methodID;

    CVMsysMutexLock(ee, &CVMglobals.typeidLock);
    name = referenceName(ee, memberName, &nameToken, CVM_TRUE);
    if (name == NULL) {
	methodID = CVM_METHOD_TYPEID_ERROR;
	goto exit;
    }

    sig = referenceMethodSignature(ee, memberSig, (int)strlen(memberSig),
                                   &sigToken, CVM_TRUE);
    if (sig == NULL) {
	/* there was a parse or malloc failure. somewhere. */
	/* delete anything that needs deleting */
	/* Since we call the reference functions with doInsertion == CVM_TRUE,
	 * a reference count of 1 means that an entry was just inserted by
	 * us, so we should delete it.
	 */
	if ((name != NULL) && (name->refCount == 1)) {
	    name->refCount = 0;
	    deleteNameEntry(name, nameToken, NULL);
	}
	methodID = CVM_METHOD_TYPEID_ERROR;
	goto exit;
    }

    methodID = referenceNameAndType(ee, nameToken, sigToken, CVM_TRUE);
    if (methodID == CVM_METHOD_TYPEID_ERROR) {
	if ((name != NULL) && (name->refCount == 1)) {
	    name->refCount = 0;
	    deleteNameEntry(name, nameToken, NULL);
	}
	if ((sig != NULL) && (sig->refCount == 1)) {
	    sig->refCount = 0;
	    deleteMethodSignatureEntry(sig, sigToken, NULL);
	}
	CVMassert(CVMtypeidIsSameMethod(methodID, CVM_METHOD_TYPEID_ERROR));
	/* goto exit; */
    }
exit:
    CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);
    return methodID;
}


CVMMethodTypeID
CVMtypeidCloneMethodID(CVMExecEnv *ee, CVMMethodTypeID cookie)
{
    CVMNameTypeID nameID = CVMtypeidGetMemberName(cookie);
    CVMSigTypeID typeID = CVMtypeidGetMemberType(cookie);
    CVMTypeIDToken nameCookie = CVMtypeidGetToken(nameID);
    CVMTypeIDToken typeCookie = CVMtypeidGetToken(typeID);
    CVMTypeIDNameEntry *thisName;
    CVMTypeIDMethodSigEntry *thisType;

    CVMsysMutexLock(ee, &CVMglobals.typeidLock );

    thisName = indexName(nameCookie, NULL);
    conditionalIncRef(thisName);

    thisType = indexMethodSig(typeCookie, NULL);
    conditionalIncRef(thisType);

    /*
	CVMconsolePrintf("typeidCloneMethodID of name 0x%x->refCount"
                         " to %d\n", nameCookie, thisName->refCount);
	CVMconsolePrintf("               and  of type 0x%x->refCount"
                         " to %d\n", typeCookie, thisType->refCount);
    */

    CVMsysMutexUnlock(ee, &CVMglobals.typeidLock );

    return cookie;
}


void
CVMtypeidDisposeMethodID(CVMExecEnv *ee, CVMMethodTypeID cookie)
{
    CVMNameTypeID nameID = CVMtypeidGetMemberName(cookie);
    CVMSigTypeID typeID = CVMtypeidGetMemberType(cookie);
    CVMTypeIDToken nameCookie = CVMtypeidGetToken(nameID);
    CVMTypeIDToken typeCookie = CVMtypeidGetToken(typeID);
    CVMTypeIDNameEntry *thisName;
    genericTableSegment *nameSeg;
    CVMTypeIDMethodSigEntry *thisType;
    genericTableSegment *typeSeg;

    CVMsysMutexLock(ee, &CVMglobals.typeidLock );

    thisName = indexName( nameCookie, &nameSeg );
    if ( thisName->refCount != MAX_COUNT ){
	if ( --(thisName->refCount) == 0 ){
	    deleteNameEntry(thisName, nameCookie,
                            (CVMTypeIDNameSegment *)nameSeg);
	}
    }

    thisType = indexMethodSig( typeCookie, &typeSeg );
    if ( thisType->refCount != MAX_COUNT ){
	if ( --(thisType->refCount) == 0 ){
	    deleteMethodSignatureEntry(thisType, typeCookie,
                                       (CVMTypeIDMethodSigSegment *)
                                       typeSeg);
	}
    }

    CVMsysMutexUnlock(ee, &CVMglobals.typeidLock );
}

/*
 * Make a type ID out of a field name and a signature
 */
CVMFieldTypeID
CVMtypeidLookupFieldIDFromNameAndSig(CVMExecEnv *ee,
                                     const CVMUtf8 *memberName,
                                     const CVMUtf8 *memberSig)
{
    CVMTypeIDNameEntry *name;
    CVMTypeIDClassEntry *type;
    CVMTypeIDToken nameToken;
    CVMTypeIDToken sigToken;
    CVMFieldTypeID fieldID;

    name = referenceName(ee, memberName, &nameToken, CVM_FALSE);
    if (name == NULL) {
	/* no such name */
	return CVM_FIELD_TYPEID_ERROR;
    }
    type = referenceFieldSignature(ee, memberSig, (int)strlen(memberSig),
                                   CVM_FALSE, &sigToken);
    /* NOTE: we don't check (type == NULL) here because it is possible to have
       a NULL type entry for primitive classes.  So instead, we'll check the
       sigToken: */
    if (sigToken == CVM_TYPEID_ERROR) {
	/* there was a malloc or lookup failure. somewhere. */
	/* any error has already been thrown */
	return CVM_FIELD_TYPEID_ERROR;
    }
    fieldID = referenceNameAndType(ee, nameToken, sigToken, CVM_FALSE);
    return fieldID;
}

CVMFieldTypeID
CVMtypeidNewFieldIDFromNameAndSig(CVMExecEnv *ee, const CVMUtf8 *memberName,
                                  const CVMUtf8 *memberSig)
{
    CVMTypeIDNameEntry *name;
    CVMTypeIDClassEntry *sig;
    CVMTypeIDToken nameToken;
    CVMTypeIDToken sigToken;
    CVMFieldTypeID fieldID;

    CVMsysMutexLock(ee, &CVMglobals.typeidLock);
    name = referenceName(ee, memberName, &nameToken, CVM_TRUE);
    if (name == NULL) {
	fieldID = CVM_FIELD_TYPEID_ERROR;
	goto exit;
    }
    sig = referenceFieldSignature(ee, memberSig, (int)strlen(memberSig),
                                  CVM_TRUE, &sigToken);
    /* NOTE: we don't check (sig == NULL) here because it is possible to have a
       NULL sig entry for primitive classes.  So instead, we'll check the
       sigToken: */
    if (sigToken == CVM_TYPEID_ERROR) {
	/* there was a malloc failure in referenceFieldSignature */
	/* Since we call the reference functions with doInsertion == CVM_TRUE,
	 * a reference count of 1 means that an entry was just inserted by
	 * us, so we should delete it.
	 */
	if (name->refCount == 1){
	    name->refCount = 0;
	    deleteNameEntry(name, nameToken, NULL);
	}
	fieldID = CVM_FIELD_TYPEID_ERROR;
	goto exit;
    }

    fieldID = referenceNameAndType(ee, nameToken, sigToken, CVM_TRUE);
    if (fieldID == CVM_FIELD_TYPEID_ERROR) {
	if ((name != NULL) && (name->refCount == 1)) {
	    name->refCount = 0;
	    deleteNameEntry(name, nameToken, NULL);
	}
        CVMassert(CVMtypeidIsSameField(fieldID, CVM_FIELD_TYPEID_ERROR));
        /* goto exit; */
    }
exit:
    CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);
    return fieldID;
}

CVMFieldTypeID
CVMtypeidCloneFieldID(CVMExecEnv *ee, CVMFieldTypeID fieldID)
{
    CVMNameTypeID nameID = CVMtypeidGetMemberName(fieldID);
    CVMSigTypeID sigID = CVMtypeidGetMemberType(fieldID);
    CVMTypeIDToken nameToken = CVMtypeidGetToken(nameID);
    CVMTypeIDToken sigToken = CVMtypeidGetToken(sigID);
    CVMTypeIDNameEntry *thisName;
    CVMTypeIDClassEntry *thisType;

    CVMsysMutexLock(ee, &CVMglobals.typeidLock);

    thisName = indexName(nameToken, NULL);
    conditionalIncRef(thisName);

    if (isTableEntry(sigToken)) {
	thisType = indexClass(sigToken, NULL);
	conditionalIncRef(thisType);
    }

    CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);

    return fieldID;
}


void
CVMtypeidDisposeFieldID(CVMExecEnv *ee, CVMFieldTypeID fieldID)
{
    CVMNameTypeID nameID = CVMtypeidGetMemberName(fieldID);
    CVMSigTypeID sigID = CVMtypeidGetMemberType(fieldID);
    CVMTypeIDToken nameToken = CVMtypeidGetToken(nameID);
    CVMTypeIDToken sigToken = CVMtypeidGetToken(sigID);
    CVMTypeIDNameEntry *thisName;
    genericTableSegment *nameSeg;

    CVMsysMutexLock(ee, &CVMglobals.typeidLock);

    thisName = indexName(nameToken, &nameSeg);
    if (thisName->refCount != MAX_COUNT) {
	if (--thisName->refCount == 0) {
	    deleteNameEntry(thisName, nameToken,
                            (CVMTypeIDNameSegment *)nameSeg);
	}
    }

    if (isTableEntry(sigToken)) {
	decrefClassTypeEntry(sigToken);
    }

    CVMsysMutexUnlock(ee, &CVMglobals.typeidLock);
}


/*****************************************************************/

char
CVMtypeidGetReturnType(CVMMethodTypeID methodID)
{
    CVMSigTypeID sigID = CVMtypeidGetMemberType(methodID);
    CVMTypeIDToken sigToken = CVMtypeidGetToken(sigID);
    CVMTypeIDMethodSigEntry *thisEntry;
    thisEntry = indexMethodSig(sigToken, NULL);
    return ((thisEntry->nParameters <= (FORM_SYLLABLESPERDATUM-2)) ?
            (thisEntry->form.formdata) : (thisEntry->form.formp->data[0]))
           & 0xf;
}

/*
 * Returns true if the ID is a ref. This works for methods that return 
 * references.
 * CVMtypeidFieldIsRef is a macro.
 */

CVMBool
CVMtypeidMethodReturnsRef(CVMMethodTypeID methodID)
{
    return CVMtypeidGetReturnType(methodID) == CVM_TYPEID_OBJ;
}

/*
 * Return information about a method signature's terse form.
 */
void
CVMtypeidGetTerseSignature(CVMMethodTypeID methodID, CVMterseSig *tsp)
{
    CVMSigTypeID sigID = CVMtypeidGetMemberType(methodID);
    CVMTypeIDToken sigToken = CVMtypeidGetToken(sigID);
    CVMTypeIDMethodSigEntry *mtp = indexMethodSig(sigToken, NULL);
    if ((tsp->nParameters = mtp->nParameters) <= (FORM_SYLLABLESPERDATUM-2)) {
	tsp->datap = &mtp->form.formdata;
    } else {
	tsp->datap = mtp->form.formp->data;
    }
}

void
CVMtypeidGetTerseSignatureIterator(CVMMethodTypeID methodID,
                                   CVMterseSigIterator *tsp)
{
    CVMSigTypeID sigID = CVMtypeidGetMemberType(methodID);
    CVMTypeIDToken sigToken = CVMtypeidGetToken(sigID);
    CVMTypeIDMethodSigEntry *mtp = indexMethodSig(sigToken, NULL);
    tsp->thisSig.nParameters = mtp->nParameters;
    if (tsp->thisSig.nParameters <= (FORM_SYLLABLESPERDATUM - 2)) {
	tsp->thisSig.datap = &mtp->form.formdata;
    } else {
	tsp->thisSig.datap = mtp->form.formp->data;
    }
    tsp->word = 0;
    tsp->syllableInWord = 1; /* since 0 is return type */
}

void
CVMtypeidGetSignatureIterator(CVMMethodTypeID methodID, CVMSigIterator *result)
{
    CVMSigTypeID sigID = CVMtypeidGetMemberType(methodID);
    CVMTypeIDToken sigToken = CVMtypeidGetToken(sigID);
    CVMTypeIDMethodSigEntry * m;
    CVMUint32*  formdata;
    int	        nDetail;
    CVMTypeIDToken returnType;

    m = indexMethodSig(sigToken, NULL);
    /*
     * Have to look at the form to determine how many
     * details there are.
     */
    nDetail = getSignatureInfo(m, &formdata, &result->parameterDetails);

    CVMtypeidGetTerseSignatureIterator(methodID, &result->terseSig);
    returnType = CVM_TERSE_ITER_RETURNTYPE(result->terseSig);
    if (returnType == CVM_TYPEID_OBJ) {
	result->returnType = *(result->parameterDetails++);
    } else {
	result->returnType = returnType;
    }
}

/*
 * CVMtypeidGetArgsSize - returns the total number of words that the
 * method arguments occupy.
 *
 * WARNING: does not account for the "this" argument.
 */
CVMUint16
CVMtypeidGetArgsSize(CVMMethodTypeID methodID)
{
    CVMTypeIDToken argType;
    CVMterseSigIterator terseSig;
    CVMUint16 argsSize = 0;
    
    CVMtypeidGetTerseSignatureIterator(methodID, &terseSig);
    do {
	argType = CVM_TERSE_ITER_NEXT(terseSig);
	switch (argType) {
	case CVM_TYPEID_ENDFUNC:
	    break;
	case CVM_TYPEID_LONG:
	case CVM_TYPEID_DOUBLE:
	    argsSize += 2;
	    break;
	case CVM_TYPEID_INT:
	case CVM_TYPEID_SHORT:
	case CVM_TYPEID_CHAR:
	case CVM_TYPEID_BYTE:
	case CVM_TYPEID_FLOAT:
	case CVM_TYPEID_BOOLEAN:
	case CVM_TYPEID_OBJ:
	    argsSize++;
	    break;
	default:
	    CVMassert(CVM_FALSE);
	}
    } while (argType != CVM_TYPEID_ENDFUNC);

    return argsSize;
}

#ifdef CVM_JIT
/*
 * Returns the total number of arguments that the method has.
 *
 * WARNING: does not account for the "this" argument.
 */
extern CVMUint16
CVMtypeidGetArgsCount(CVMMethodTypeID methodID)
{
    CVMSigTypeID sigID = CVMtypeidGetMemberType(methodID);
    CVMTypeIDToken sigToken = CVMtypeidGetToken(sigID);
    CVMTypeIDMethodSigEntry *mtp = indexMethodSig(sigToken, NULL);
    return mtp->nParameters;
}

#endif

